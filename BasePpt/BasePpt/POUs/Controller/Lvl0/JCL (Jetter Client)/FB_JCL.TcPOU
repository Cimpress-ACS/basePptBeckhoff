<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.26">
  <POU Name="FB_JCL" Id="{653d1efa-6adf-4284-8977-9316a5e2dba4}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_JCL EXTENDS FB_CtrlBase
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_JCL;
	/// pointer to function block
	p_fbTCP: POINTER TO FB_TCP;
	pTCP_CIF: POINTER TO BASE_PLC.T_Ctrl_CIf;
	fbStateLookup: FB_LookupTable;
	fbCommandLookup: FB_LookupTable;
	bolServerConnectionError: BOOL;
	/// variables for receiving msgs
	m_naNextMsg: ARRAY[0..MAX_DATASET_SIZE] OF BYTE;
	m_paNextMsg: POINTER TO ARRAY[0..MAX_DATASET_SIZE] OF BYTE;
	m_puNextMsg: POINTER TO U_JCL_Message;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
ToDo: DSC...

History:
Version		Date			Author				Comment
---------------------------------------------------------------------------------------------------
0.00.1		20.05.2014		AVME/DSC			Start history. Insert all basic functionalities.
0.00.2		28.04.2015		VP/RE				Added bolMaintenanceInProgress.
___________________________________________________________________________________________________*)

SUPER^();]]></ST>
    </Implementation>
    <Method Name="getCtrlSIf" Id="{296d8e44-410f-44e7-8197-7f282e489a38}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCtrlSIf'}
METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_JCL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdSTANDBY" Id="{36a43e8f-6bb6-4396-981e-6aec547a8539}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdSTANDBY'}
METHOD PROTECTED cmdSTANDBY : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for STANDBY
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Standby;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CLEANINGBusy" Id="{515bb4f2-62b4-4509-b6d7-9bd12ca30a58}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CLEANINGBusy'}
METHOD PROTECTED sta_CLEANINGBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdCLEAN();
		END_IF

		me.SubStateMachine.intState := cSUB_WaitForCleaningToStart;		
		me.SubStateMachine.intStateNext := cSUB_WaitForCleaningToStart;		
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_CleanPrintHeads;
			END_IF
		END_IF	
		
		CASE me.SubStateMachine.intState OF
			cSUB_WaitForCleaningToStart:
				IF SIf.Cur.intJETState = cSTA_CleanPrintHeadsBusy THEN
					me.SubStateMachine.intStateNext := cSUB_CleaningBusy;
				END_IF
				
				IF me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiCleaningStartTimeout_ms THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.CleaningError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
				END_IF
			cSUB_CleaningBusy:
				// Wait for feedback -> maintenance automatic done	
				IF (SIf.Cur.intJETState = JCL_CmdState.cSTA_CleanPrintHeads) THEN
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeads;
				END_IF
		END_CASE
		
		IF SIf.Cur.intJETState = cSTA_ERROR THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.CleaningError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.SubStateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF
	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{5308f54e-fe8d-4221-9034-66ae07629cb3}">
      <Declaration><![CDATA[{attribute 'object_name' := 'StateMachine'}
METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	JCL_CmdState.cSTA_ConnectBusy: 
        THIS^.sta_CONNECTBusy();
	cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
	cSTA_RUN: 
        THIS^.sta_RUN();
	JCL_CmdState.cSTA_StandbyBusy: 
        THIS^.sta_STANDBYBusy();
	JCL_CmdState.cSTA_Standby: 
        THIS^.sta_STANDBY();	
	JCL_CmdState.cSTA_CleanPrintHeadsBusy: 
        THIS^.sta_CLEANINGBusy();
	JCL_CmdState.cSTA_CleanPrintHeads: 
        THIS^.sta_CLEANING();	
	JCL_CmdState.cSTA_CalibrationBusy:
		THIS^.sta_CALIBRATIONBusy();
	JCL_CmdState.cSTA_Calibration:
		THIS^.sta_CALIBRATION();
	JCL_CmdState.cSTA_MANUALMODE:
		THIS^.sta_MANUALMODE();
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{556f1e63-60be-4b6b-bf31-c9ae7fe1ee9f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFF'}
METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		CASE me.intCmd OF
			Base_PLC.cCMD_RUN: 				
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;	
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			JCL_CmdState.cCMD_CleanPrintHeads: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
		END_CASE
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_MANUALMODE" Id="{57b21fe2-6d88-4268-b531-a2b3efb37588}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_MANUALMODE'}
METHOD PROTECTED sta_MANUALMODE : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle;
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		SIf.Cur.bolNeedsCleaning := FALSE;
		
		// set Warning
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualWarning,0,ADR(SIf.Alm),E_AlmState.SET,CIf.Job.eMe_ActivAlmClass);
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		IF SIf.Cfg.bolJetterManualModeAllowed THEN
			IF SIf.Cur.bolIsRemoteControlled THEN
				me.StateMachine.intStateNext := cSTA_OFFBusy;
			END_IF
		ELSE
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		
		// clear Warning
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualWarning,0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
		
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{58a1a65a-6b15-458d-bfde-693fdee9bd47}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CtrlInit'}
METHOD CtrlInit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// one time first cyclic call!
// Open the TCP communication to jetter remote server to get the actual machine state
me.StateMachine.intStateNext := JCL_CmdState.cSTA_ConnectBusy;

// get child if
pTCP_CIF 	:= AddChild(p_fbTCP^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdOFF" Id="{59dfe850-7730-45f1-8cac-9075556df3da}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdOFF'}
METHOD PROTECTED cmdOFF : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for OFF
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Off;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PONBusy" Id="{654f0c39-c043-40ea-8aa5-b5bce8072d53}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PONBusy'}
METHOD PROTECTED sta_PONBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF NOT (CIf.SwCfg.bolSimulation) THEN
			// If the socket is already connected, trigger a reconnet.
			IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) OR (pTCP_CIF^.Job.intState = Base_PLC.cSTA_ERROR) THEN
				// Initialize sub state machine
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingSocketClosed;		
				me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
				// Connect to jetter server
				pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Close;	
			ELSE		
				// Initialize sub state machine
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;		
				me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
				// Connect to jetter server
				pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;	
			END_IF
		ELSE
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= FALSE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := BASE_PLC.cSTA_PON;
		END_IF
		
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.SubStateMachine.intState OF
				
			// -----------------------------------------		
			JCL_CmdState.cSUB_WaitingSocketClosed:	
				IF (CIf.SwCfg.bolSimulation) THEN
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;	
				ELSE							
					// Wait for socket closed
					IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Close) THEN			
						me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;	
					END_IF		
				END_IF
		
			// -----------------------------------------		
			JCL_CmdState.cSUB_WaitingForConnection:		
				IF (CIf.SwCfg.bolSimulation) THEN
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_SendPon;	
				ELSE							
					// Connect to jetter server
					pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;	
						
					// Wait for connection
					IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) THEN			
						me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_SendPon;	
					END_IF		
				END_IF
			
			// -----------------------------------------		
			JCL_CmdState.cSUB_SendPon:
				IF (me.intCmd = cCMD_PON) THEN
					cmdPON();
				END_IF
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_Done;
						
			// -----------------------------------------		
			JCL_CmdState.cSUB_Done:
				me.StateMachine.intStateNext := cSTA_PON;
		
		END_CASE
		
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="CtrlSIf" Id="{6abba3ed-3c06-4eaa-81e7-6325df6e6121}">
      <Declaration><![CDATA[PROPERTY CtrlSIf : POINTER TO T_Ctrl_SIf_JCL
]]></Declaration>
      <Get Name="Get" Id="{e8b677a8-d50f-4c4d-9e73-544009b60812}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[CtrlSIf := ADR(SIf);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="RequestState" Id="{6c821a16-9064-48b5-9392-ee72e76d8011}">
      <Declaration><![CDATA[{attribute 'object_name' := 'RequestState'}
METHOD PROTECTED RequestState : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Request jetter state
IF NOT (CIf.SwCfg.bolSimulation) THEN
	stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
	stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
	stNextCommand.usiCommand := JCL_CMD_RequestState;
	pNextCommand := ADR(stNextCommand);	
	p_fbTCP^.M_Push(paPushMsg := pNextCommand);		
END_IF	]]></ST>
      </Implementation>
    </Method>
    <Property Name="TCP" Id="{6da83431-622b-4c04-b4af-aff27d6d87be}">
      <Declaration><![CDATA[PROPERTY TCP : POINTER TO FB_TCP
]]></Declaration>
      <Get Name="Get" Id="{170b5bbd-c71e-4130-8615-008efbd317d4}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[TCP := p_fbTCP;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{78ad4316-339b-44c5-aaff-b539a8e438d1}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[p_fbTCP := TCP;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="cmdCALIBRATION" Id="{76030ac2-b263-4e17-9080-2aac7f7b88b4}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdCALIBRATION'}
METHOD PROTECTED cmdCALIBRATION : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for CALIBRATION
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Calibration;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{791ac03d-e850-4050-ae04-95c6b9eb127d}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PON'}
METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF
	

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN	
		
		IF (SIf.Cur.intJETState = cSTA_EOFF) OR (SIf.Cur.intJETState = cSTA_EOFFBusy) THEN
			me.StateMachine.intStateNext := cSTA_EOFFBusy;
		ELSIF SIf.Cur.bolIsLocalControlled THEN
			me.StateMachine.intStateNext := cSTA_MANUALMODE;
		ELSE
			me.StateMachine.intStateNext := cSTA_OFFBusy;
		END_IF
	
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CALIBRATIONBusy" Id="{8a54be7c-6900-4651-bb67-5b804ef8e913}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CALIBRATIONBusy'}
METHOD PROTECTED sta_CALIBRATIONBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdCALIBRATION();
		END_IF
		
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_Calibration;
			END_IF
		END_IF	
	
		// Wait for feedback -> maintenance automatic done	
		IF (SIf.Cur.intJETState = JCL_CmdState.cSTA_Calibration) THEN
			me.StateMachine.intStateNext := JCL_CmdState.cSTA_Calibration;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

		
	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFF" Id="{8c5a4ef0-e6c0-44f4-bbef-a93d76be3e6c}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_EOFF'}
METHOD PROTECTED sta_EOFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		IF (SIf.Cur.intJETState <> cSTA_EOFF) AND (SIf.Cur.intJETState <> cSTA_EOFFBusy) THEN
			IF SIf.Cur.bolIsLocalControlled THEN
				me.StateMachine.intStateNext := cSTA_MANUALMODE;
			ELSE
				me.StateMachine.intStateNext := cSTA_OFFBusy;
			END_IF
		END_IF
		
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterEOff,0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CLEANING" Id="{8f09f170-5512-41a3-9c39-bd9116033caf}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CLEANING'}
METHOD PROTECTED sta_CLEANING : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

		SIf.Cur.bolNeedsCleaning:= FALSE;			
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF	
			Base_PLC.cCMD_RUN:
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;	
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;			
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildAlmClass" Id="{90ddf29a-ca4a-4017-9fc1-27742aa7e5f1}">
      <Declaration><![CDATA[{attribute 'object_name' := 'checkChildAlmClass'}
METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// If there is a TCP connection problem to the server
IF (pTCP_CIF^.Job.eMe_ActivAlmClass >= E_AlmClass.TSTOP) THEN
	bolServerConnectionError:= TRUE;
	// set me alarm class OFF
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdCLEAN" Id="{c1e87bbb-d38a-4493-8c2d-ba54ea97a57f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdCLEAN'}
METHOD PROTECTED cmdCLEAN : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for CLEAN
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_CleanPrintHeads;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{c336f897-42f5-4a0b-ae9b-7540dcddc531}">
      <Declaration><![CDATA[{attribute 'object_name' := 'Always'}
METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// not inherite from base !!!  special behaviour for this controller
// SUPER^.Always();

// Conditions Always
IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	//me.StateMachine.intStateNext := cSTA_OFFBusy;
	me.bolChangeBackToAUTO := FALSE;
END_IF

IF (CIf.SwCfg.bolExist=FALSE) THEN // hardware of controller does not exist
	me.StateMachine.intStateNext := cSTA_SINGLE_ANSWER;
ELSE
	// Handle command PON
	IF (me.intCmd=cCMD_PON) 
		AND (me.StateMachine.intState<>cSTA_PONBusy) AND (me.StateMachine.intState<>cSTA_PON)
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy) THEN
		me.StateMachine.intStateNext := cSTA_PONBusy;
	ELSIF (me.intCmd=cCMD_OFF) 
		AND (me.StateMachine.intState<>cSTA_PONBusy) AND (me.StateMachine.intState<>cSTA_PON)
		AND (me.StateMachine.intState<>cSTA_OFFBusy) AND (me.StateMachine.intState<>cSTA_OFF)
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)
		AND (me.StateMachine.intState<>JCL_CmdState.cSTA_MANUALMODE) THEN
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF
		
// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// Always handle recieve data from jetter server
	IF NOT CIf.SwCfg.bolSimulation THEN
		THIS^.HandleReceiveData();
	END_IF
	
	// Request state
	// ------------------------------
	IF (me.intCmd=cCMD_RequestState) THEN
		// Request state one time
		CIf.Job.intACmd := Base_PLC.cCMD_DONE;
		CIf.Job.intMCmd := Base_PLC.cCMD_DONE;
		THIS^.RequestState();
	END_IF
	
	// Reset Jetter alarms
	// ------------------------------
	// Can be done over command "cCMD_ResetAlarm" or normal global AlmReset
	IF (me.intCmd=cCMD_ResetAlarm) OR ((CIf.Job.bolAlmReset = TRUE) AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit)) THEN
		CIf.Job.bolAlmReset := FALSE;
		IF (me.intCmd=cCMD_ResetAlarm) THEN
			CIf.Job.intACmd := Base_PLC.cCMD_DONE;
			CIf.Job.intMCmd := Base_PLC.cCMD_DONE;
		END_IF
		// Reset Jetter alarms one time
		THIS^.ResetAlarms();
	END_IF
	
	// EOFF and MANUAL
	IF (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy) AND (me.StateMachine.intState>cSTA_PON)
	  AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit)  THEN
		IF (SIf.Cur.intJETState = cSTA_EOFF) OR (SIf.Cur.intJETState = cSTA_EOFFBusy) THEN
			me.StateMachine.intStateNext := cSTA_EOFFBusy;
		ELSIF (SIf.Cur.bolIsLocalControlled) AND (me.StateMachine.intState<>cSTA_MANUALMODE) AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) THEN
			me.StateMachine.intStateNext := cSTA_MANUALMODE;
		END_IF
	END_IF
		
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFFBusy" Id="{c5edad98-30e5-41ef-9adf-477110a900d8}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_EOFFBusy'}
METHOD PROTECTED sta_EOFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterEOff,0,ADR(SIf.Alm),E_AlmState.SET,CIf.Job.eMe_ActivAlmClass);
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateNext := cSTA_EOFF;
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{c8e413b0-cba2-470b-9102-95d7a8fea93e}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFFBusy'}
METHOD PROTECTED sta_OFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF (CIf.SwCfg.bolSimulation) THEN 
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= FALSE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := BASE_PLC.cSTA_OFF;
		ELSE 
			SIf.Cur.bolNeedsCleaning := FALSE;
			cmdOFF();
		END_IF
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Wait for feedback -> OFF
		IF (SIf.Cur.intJETState = BASE_PLC.cSTA_OFF) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{ca7f9e3f-63f4-4555-b1e8-2b882bfddf30}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUNBusy'}
METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF CIf.SwCfg.bolSimulation THEN
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= TRUE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := cSTA_RUN;
		ELSE
			cmdRUN();
		END_IF
			 
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Wait for feedback -> RUN
		IF (SIf.Cur.intJETState = cSTA_RUN) THEN
			me.StateMachine.intStateNext := BASE_PLC.cSTA_RUN;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBYBusy" Id="{d928f2ad-c37d-490e-a6a7-2b24c6411c3b}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_STANDBYBusy'}
METHOD PROTECTED sta_STANDBYBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdSTANDBY();
		END_IF
		
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.bolReadyForProduction:= TRUE;			
				SIf.Cur.bolRunning:= TRUE;		
				SIf.Cur.bolNeedsAttention:= FALSE;			
				SIf.Cur.bolError:= FALSE;			
				SIf.Cur.bolCleaningIncomplete:= FALSE;			
				SIf.Cur.bolIsLocalControlled:= FALSE;		
				SIf.Cur.bolIsRemoteControlled:= TRUE;
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_Standby;
			END_IF
		END_IF	
	
		// Wait for feedback -> standby	
		IF (SIf.Cur.intJETState  = JCL_CmdState.cSTA_Standby) THEN
			me.StateMachine.intStateNext := JCL_CmdState.cSTA_Standby;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CONNECTBusy" Id="{d9f12384-1f30-48ca-9331-c1298072043c}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CONNECTBusy'}
METHOD sta_CONNECTBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	
		// **********************************************************************************
		// This state will be executed one time after startup or after an error ack.
		// State open the TCP communication to jetter remote server to get the actual machine state
		// **********************************************************************************
		// Reset state 
		SIf.Cur.intJETState:= 0;
		
		// Connect to the jetter server
		pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;
		
		// Initialize sub state machine
		me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;		
		me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// -----------------------------------------------
		// Sub state machine handle 
		// -----------------------------------------------
		CASE me.SubStateMachine.intState OF
			
			JCL_CmdState.cSUB_WaitingForConnection:			
				// Wait for connection
				IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) THEN	
					// Request jetter states the first time after TCP client connected				
					THIS^.RequestState();		
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForState;	
				END_IF
			
			JCL_CmdState.cSUB_WaitingForState:
				// Wait for first status msg 
				IF (SIf.Cur.intJETState > 0) THEN 
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_Done;
				END_IF	

			JCL_CmdState.cSUB_Done:
				// Change to the init state
				me.StateMachine.intStateNext := SIf.Cur.intJETState;
			
		END_CASE
			
	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{e00be5f7-dd05-4b46-b2b0-9660f35afb71}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUN'}
METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		IF (SIf.Cfg.bolJetterManualModeAllowed) THEN
			IF SIf.Cur.bolIsLocalControlled THEN
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
			END_IF			
			
			IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		ELSE
			IF (SIf.Cur.intJETState <> cSTA_RUN) THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterNotRun,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
				
			IF SIf.Cur.bolIsLocalControlled THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

		IF (me.StateMachine.intStateNext<>Base_PLC.cSTA_ERROR) AND (me.StateMachine.intStateNext<>JCL_CmdState.cSTA_MANUALMODE)THEN
			CASE me.intCmd OF
				Base_PLC.cCMD_RUN:
					me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;
				JCL_CmdState.cCMD_CleanPrintHeads:
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
				JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			END_CASE
		END_IF
		
	END_IF
	

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{e1c312d7-a67c-4057-b56c-13f76f80f10c}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERROR'}
METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

	
// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdPON" Id="{e7846860-4b92-4abf-a39b-2e23b2a42de9}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdPON'}
METHOD PROTECTED cmdPON : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for PON
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_PowerOn;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBY" Id="{e992415a-6e20-4037-b48f-d90709c0e0f9}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_STANDBY'}
METHOD PROTECTED sta_STANDBY : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF
			BASE_PLC.cCMD_RUN:
				me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
			JCL_CmdState.cCMD_Standby:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			JCL_CmdState.cCMD_CleanPrintHeads: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
			JCL_CmdState.cCMD_Calibration: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CalibrationBusy;	
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERRORQuit" Id="{eab34da0-1294-4781-ab7c-e523a624984f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERRORQuit'}
METHOD PROTECTED sta_ERRORQuit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// evtl. wait time if reset of device is necessary and then decide to go to states or ERROR state
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
			CIf.Job.bolAlmReset := FALSE;
		END_IF
		
		// State Change Condition
		IF (pTCP_CIF^.Job.bolAlmReset = FALSE) THEN
			IF pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect THEN
				IF SIf.Cfg.bolJetterManualModeAllowed THEN
					IF SIf.Cur.bolIsLocalControlled THEN
						me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
					ELSE
						me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
					END_IF
				ELSE
					IF SIf.Cur.bolIsLocalControlled THEN
						me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
					ELSE
						me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
					END_IF
				END_IF
			ELSE
				// If the error was triggered because of an TCP connection problem to the server
				IF (bolServerConnectionError) AND (pTCP_CIF^.Job.eMe_ActivAlmClass = E_AlmClass.NONE) THEN
					bolServerConnectionError:= FALSE;
					// Try to reopen the connection to server
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_ConnectBusy;
				END_IF
			END_IF
		END_IF
	END_IF

	
// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{ecda697d-3315-4078-829a-5c07a7917a21}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCmdState'}
METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states

IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime	
	IF (bolState=FALSE) THEN
		// States's
		CASE intCmdState OF
			JCL_CmdState.cCMD_Standby: 
				getCmdState := 'Standby';
			JCL_CmdState.cCMD_CleanPrintHeads: 
				getCmdState := 'CleanPrintHeads';		
				
		END_CASE;
	ELSE
		// States's
		CASE intCmdState OF			
			// Main states
			JCL_CmdState.cSTA_StandbyBusy: 
				getCmdState := 'StandbyBusy'; 
			JCL_CmdState.cSTA_Standby:
				getCmdState := 'Standby';			
			JCL_CmdState.cSTA_ConnectBusy:
				getCmdState := 'ConnectBusy';
			JCL_CmdState.cSTA_CleanPrintHeadsBusy: 
				getCmdState := 'CleanPrintHeadsBusy'; 
			JCL_CmdState.cSTA_CleanPrintHeads:
				getCmdState := 'CleanPrintHeads';		
			JCL_CmdState.cSTA_CalibrationBusy:
				getCmdState := 'CalibrationBusy';	
			JCL_CmdState.cSTA_Calibration:
				getCmdState := 'Calibration';	
			JCL_CmdState.cSTA_MANUALMODE:
				getCmdState := 'Jetter Manual';	
						
			// Sub states
			JCL_CmdState.cSUB_WaitingForConnection:
				getCmdState := 'WaitingForConnection';
			JCL_CmdState.cSUB_WaitingForState:
				getCmdState := 'WaitingForState';
			JCL_CmdState.cSUB_Done:
				getCmdState := 'Done';			
			JCL_CmdState.cSUB_WaitForCleaningToStart:
				getCmdState := 'WaitForCleaningToStart';
			JCL_CmdState.cSUB_CleaningBusy:
				getCmdState := 'CleaningBusy';			
		END_CASE;
	END_IF 
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdRUN" Id="{f461cd4d-8c10-4203-b54b-f65d70f699d7}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdRUN'}
METHOD PROTECTED cmdRUN : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for RUN
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Run;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CALIBRATION" Id="{f4c7a7ff-10f9-490e-999b-fe4298d5acb3}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CALIBRATION'}
METHOD PROTECTED sta_CALIBRATION : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF		
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;			
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{f609fb77-8c5d-4bf2-96c1-8df113779cc5}">
      <Declaration><![CDATA[{attribute 'object_name' := 'FB_init'}
METHOD FB_init : BOOL
VAR_INPUT
	/// if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	/// if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	iIdx: UINT;
	iLength: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
iLength := SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0]);
iIdx := 0;

WHILE (iIdx < iLength) AND (CIf.Job.aCmdList[iIdx].intCmd <> cCMD_INITIALIZED) DO
	iIdx := iIdx + 1; 
END_WHILE

IF (iIdx < iLength) THEN
// Add configuration of own comands	
	CIf.Job.aCmdList[iIdx].intCmd := BASE_PLC.cCMD_RUN;
	CIf.Job.aCmdList[iIdx].strName := 'RUN'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
    iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_Standby;
	CIf.Job.aCmdList[iIdx].strName := 'STANDBY'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_CleanPrintHeads;
	CIf.Job.aCmdList[iIdx].strName := 'CLEANING'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_Calibration;
	CIf.Job.aCmdList[iIdx].strName := 'CALIBRATION'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_ResetAlarm;
	CIf.Job.aCmdList[iIdx].strName := 'RESET ALARM'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_RequestState;
	CIf.Job.aCmdList[iIdx].strName := 'REQUEST STATE'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
ELSE
	// Error if the aCmdList Array is to small
END_IF

// set name of class/typ
CIf.Info.strType := 'FB_JCL';
CIf.Info.strFullName := 'Jetter Client';

// set alarm class
SIf.Alm[E_ALM_JCL.JetterNotRun].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterNotRun].strText := 'Jetter is not in RUN';
SIf.Alm[E_ALM_JCL.JetterManualWarning].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[E_ALM_JCL.JetterManualWarning].strText := 'Manual Operation';
SIf.Alm[E_ALM_JCL.JetterManualError].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterManualError].strText := 'Manual Operation';
SIf.Alm[E_ALM_JCL.JetterEOff].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterEOff].strText := 'Jetter in EOFF';
SIf.Alm[E_ALM_JCL.JetterCommunicationLost].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterCommunicationLost].strText := 'Jetter Communication Lost';
SIf.Alm[E_ALM_JCL.CleaningError].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.CleaningError].strText := 'Cleaning Error';


// *******************************************************************************
// initial values
// *******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolEnable := TRUE;
CIf.SwCfg.bolSimulation :=  FALSE;

// Fill the lookup table with all valid jetter states
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_EOFFBusy, iAddValue:= 3);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_EOFF, iAddValue:= 4);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_PONBusy, iAddValue:= 1);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_PON, iAddValue:= 2);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_OFFBusy, iAddValue:= 5);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_OFF, iAddValue:= 6);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_ParkBusy, iAddValue:= 211);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_INITBusy, iAddValue:= 7);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_INIT, iAddValue:= 8);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_StandbyBusy, iAddValue:= 201);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_Standby, iAddValue:= 202);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_RUNBusy, iAddValue:= 9);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_RUN, iAddValue:= 10);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CalibrationBusy, iAddValue:= 203);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_Calibration, iAddValue:= 204);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CleanPrintHeadsBusy, iAddValue:= 205);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CleanPrintHeads, iAddValue:= 206);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceBusy, iAddValue:= 208);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceInWork, iAddValue:= 209);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceDone, iAddValue:= 210);

// prepare to recieve data
m_paNextMsg := ADR(m_naNextMsg);
m_puNextMsg := m_paNextMsg;

SIf.Par.udiCleaningStartTimeout_ms := 5000;

SIf.Cur.bolNeedsCleaning:= FALSE;	
SIf.Cur.intJETState:= 0;  // current state not yet known
SIf.Cfg.bolJetterManualModeAllowed := FALSE;

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleReceiveData" Id="{f9e56544-6ded-4fbe-a304-532bff156f35}">
      <Declaration><![CDATA[{attribute 'object_name' := 'HandleReceiveData'}
METHOD HandleReceiveData
VAR
	bPop: BOOL;
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// get next message
p_fbTCP^.M_Pop(naPopMsg => m_naNextMsg, bPop => bPop);

IF bPop THEN // something has been recieved
	CASE m_puNextMsg^.State.stHeader.uinMsgId OF

		// -----------------------------------------------
		// Handle received state
		// -----------------------------------------------
		// Note: The Status is send on Request and on Status Change
		JCL_MsgId_State:
			
			// Update the main state
			fbStateLookup.A_LookupByValue(iLookupValue := m_puNextMsg^.State.usiMainState, iFoundKey => SIf.Cur.intJETState);
	
			// Prepare additional states
			(*
			State					BIT		Description
			-------------------------------------------------------------------------------------------------
			ReadyForProduction		0		Jetter ready for production
			Running					1		Print running, in production
			NeedsAttention			2		System needs attention. Info or warning active
			Error					3		General error active
			CleaningIncomplete		4		Cleaning cycle was aborted before finishing. Production not possible.
			MaintenanceInProgress	5	 	TRUE if a maintenance work is in progress. Independent if auto or manual maintenance is in progress.
			IsLocalControlled		6		Local control active. Commands from Client are ignored
			IsRemoteControlled		7		Remote control active. Commands from Client are accepted
			*)
	
			SIf.Cur.bolReadyForProduction:= m_puNextMsg^.State.usiAddState.0;			
			SIf.Cur.bolRunning:= m_puNextMsg^.State.usiAddState.1;		
			SIf.Cur.bolNeedsAttention:= m_puNextMsg^.State.usiAddState.2;			
			SIf.Cur.bolError:= m_puNextMsg^.State.usiAddState.3;			
			SIf.Cur.bolCleaningIncomplete:= m_puNextMsg^.State.usiAddState.4;
			SIf.Cur.bolMaintenanceInProgress:= m_puNextMsg^.State.usiAddState.5;
			SIf.Cur.bolIsLocalControlled:= m_puNextMsg^.State.usiAddState.6;
			SIf.Cur.bolIsRemoteControlled:= m_puNextMsg^.State.usiAddState.7;
			
		// -----------------------------------------------
		// Handle received print info (print done)
		// -----------------------------------------------		
		JCL_MsgId_PrintDone:
			;
		
		// -----------------------------------------------
		// Handle received alarm message
		// -----------------------------------------------
		JCL_MsgId_Alarm:
			;
			
		// -----------------------------------------------
		// Handle received request for cleaning
		// -----------------------------------------------
		JCL_MsgId_ReqCleaning:
				
			SIf.Cur.bolNeedsCleaning:= TRUE;			
			SIf.Cur.strDTOfLastCleaningCycle:= m_puNextMsg^.ReqCleaning.strDTLastClean;
		
		// nothing received	
		0:
			; 
	ELSE
		; // To do: Add error	
	END_CASE
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAlarms" Id="{fc16c660-044c-4219-9c22-fdf6339ad93d}">
      <Declaration><![CDATA[{attribute 'object_name' := 'ResetAlarms'}
METHOD PROTECTED ResetAlarms : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Request jetter state
IF NOT (CIf.SwCfg.bolSimulation) THEN
	stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
	stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
	stNextCommand.usiCommand := JCL_CMD_ResetAlarm;
	pNextCommand := ADR(stNextCommand);	
	p_fbTCP^.M_Push(paPushMsg := pNextCommand);		
END_IF	]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>