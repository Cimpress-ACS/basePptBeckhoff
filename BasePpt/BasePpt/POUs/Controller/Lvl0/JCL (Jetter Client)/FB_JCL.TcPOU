<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.36">
  <POU Name="FB_JCL" Id="{0579e8a0-2ce7-470c-8a33-c91fb2bdb1ce}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_JCL EXTENDS FB_CtrlBase
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_JCL;
	/// pointer to function block
	p_fbTCP: POINTER TO FB_TCP;
	pTCP_CIF: POINTER TO BASE_PLC.T_Ctrl_CIf;
	fbStateLookup: FB_LookupTable;
	fbCommandLookup: FB_LookupTable;
	bolServerConnectionError: BOOL;
	/// variables for receiving msgs
	m_pDataChannel: POINTER TO FB_DataChannelSenderFifo;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
ToDo: DSC...

History:
Version		Date			Author				Comment
---------------------------------------------------------------------------------------------------
0.00.1		20.05.2014		AVME/DSC			Start history. Insert all basic functionalities.
___________________________________________________________________________________________________*)

SUPER^();]]></ST>
    </Implementation>
    <Method Name="sta_OFF" Id="{0445d3a0-5365-4e09-acb3-eb0dd59efb0a}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFF'}
METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		CASE me.intCmd OF
			Base_PLC.cCMD_RUN: 				
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;	
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			JCL_CmdState.cCMD_CleanPrintHeads: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
		END_CASE
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdSTANDBY" Id="{0d41c4ad-50f6-43b8-959b-06fce6445a57}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdSTANDBY'}
METHOD PROTECTED cmdSTANDBY : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for STANDBY
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Standby;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleReceiveData" Id="{14e0183b-2052-45d9-b001-9af17b110976}">
      <Declaration><![CDATA[{attribute 'object_name' := 'HandleReceiveData'}
METHOD HandleReceiveData
VAR
	bPop			: BOOL;
	naNextMsg		: ARRAY[0..MAX_DATASET_SIZE] OF BYTE;
	pNextMsg		: POINTER TO U_JCL_Message;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// get next message
p_fbTCP^.M_Pop(naPopMsg => naNextMsg, bPop => bPop);
pNextMsg := ADR(naNextMsg);

IF bPop AND (pNextMsg <> NULL) THEN  // something has been recieved
	CASE pNextMsg^.State.stHeader.uinMsgId OF

		// -----------------------------------------------
		// Handle received state
		// -----------------------------------------------
		// Note: The Status is send on Request and on Status Change
		JCL_MsgId_State:
			msg_HandleState(pNextMsg);
			
		// -----------------------------------------------
		// Handle received print info (print done)
		// -----------------------------------------------		
		JCL_MsgId_PrintDone:
			msg_HandlePrintDone(pNextMsg);
		
		// -----------------------------------------------
		// Handle received alarm message
		// -----------------------------------------------
		JCL_MsgId_Alarm:
			;
			
		// -----------------------------------------------
		// Handle received request for cleaning
		// -----------------------------------------------
		JCL_MsgId_ReqCleaning:
			msg_HandleCleaningRequest(pNextMsg);	
		
		// -----------------------------------------------
		// Handle received that an automatic cleaning was done
		// -----------------------------------------------
		JCL_MsgId_CleaningDone:
			msg_HandleCleaningDone(pNextMsg);				
		
		// nothing received	
		0:
			; 
	ELSE
		; // To do: Add error	
	END_CASE
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="msg_HandleState" Id="{1d13a4c1-951e-4dbc-a479-78d8fd70b638}">
      <Declaration><![CDATA[METHOD PROTECTED msg_HandleState : BOOL
VAR_INPUT
	pMessage			: POINTER TO U_JCL_Message;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Update the main state
fbStateLookup.A_LookupByValue(iLookupValue := pMessage^.State.usiMainState, iFoundKey => SIf.Cur.intJETState);

// Prepare additional states
(*
State				BIT		Description
-------------------------------------------------------------------------------------------------
ReadyForProduction	0		Jetter ready for production
Running				1		Print running, in production
NeedsAttention		2		System needs attention. Info or warning active
Error				3		General error active
CleaningIncomplete	4		Cleaning cycle was aborted before finishing. Production not possible.
 -					5	 	-
IsLocalControlled	6		Local control active. Commands from Client are ignored
IsRemoteControlled	7		Remote control active. Commands from Client are accepted
*)

SIf.Cur.bolReadyForProduction:= pMessage^.State.usiAddState.0;			
SIf.Cur.bolRunning:= pMessage^.State.usiAddState.1;		
SIf.Cur.bolNeedsAttention:= pMessage^.State.usiAddState.2;			
SIf.Cur.bolError:= pMessage^.State.usiAddState.3;			
SIf.Cur.bolCleaningIncomplete:= pMessage^.State.usiAddState.4;			
SIf.Cur.bolIsLocalControlled:= pMessage^.State.usiAddState.6;		
SIf.Cur.bolIsRemoteControlled:= pMessage^.State.usiAddState.7;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CALIBRATION" Id="{1d5d1b40-6b39-4960-88f0-d008f22d695c}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CALIBRATION'}
METHOD PROTECTED sta_CALIBRATION : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF		
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;			
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PONBusy" Id="{1d5e5311-f69d-4a61-8701-3271d191d706}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PONBusy'}
METHOD PROTECTED sta_PONBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF NOT (CIf.SwCfg.bolSimulation) THEN
			// If the socket is already connected, trigger a reconnet.
			IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) OR (pTCP_CIF^.Job.intState = Base_PLC.cSTA_ERROR) THEN
				// Initialize sub state machine
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingSocketClosed;		
				me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
				// Connect to jetter server
				pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Close;	
			ELSE		
				// Initialize sub state machine
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;		
				me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
				// Connect to jetter server
				pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;	
			END_IF
		ELSE
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= FALSE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := BASE_PLC.cSTA_PON;
		END_IF
		
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.SubStateMachine.intState OF
				
			// -----------------------------------------		
			JCL_CmdState.cSUB_WaitingSocketClosed:	
				IF (CIf.SwCfg.bolSimulation) THEN
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;	
				ELSE							
					// Wait for socket closed
					IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Close) THEN			
						me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;	
					END_IF		
				END_IF
		
			// -----------------------------------------		
			JCL_CmdState.cSUB_WaitingForConnection:		
				IF (CIf.SwCfg.bolSimulation) THEN
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_SendPon;	
				ELSE							
					// Connect to jetter server
					pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;	
						
					// Wait for connection
					IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) THEN			
						me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_SendPon;	
					END_IF		
				END_IF
			
			// -----------------------------------------		
			JCL_CmdState.cSUB_SendPon:
				IF (me.intCmd = cCMD_PON) THEN
					cmdPON();
				END_IF
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_Done;
						
			// -----------------------------------------		
			JCL_CmdState.cSUB_Done:
				me.StateMachine.intStateNext := cSTA_PON;
		
		END_CASE
		
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{207276c4-4237-4377-b5f0-e91d6d561dd6}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCmdState'}
METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states

IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime	
	IF (bolState=FALSE) THEN
		// States's
		CASE intCmdState OF
			JCL_CmdState.cCMD_Standby: 
				getCmdState := 'Standby';
			JCL_CmdState.cCMD_CleanPrintHeads: 
				getCmdState := 'CleanPrintHeads';		
				
		END_CASE;
	ELSE
		// States's
		CASE intCmdState OF			
			// Main states
			JCL_CmdState.cSTA_StandbyBusy: 
				getCmdState := 'StandbyBusy'; 
			JCL_CmdState.cSTA_Standby:
				getCmdState := 'Standby';			
			JCL_CmdState.cSTA_ConnectBusy:
				getCmdState := 'ConnectBusy';
			JCL_CmdState.cSTA_CleanPrintHeadsBusy: 
				getCmdState := 'CleanPrintHeadsBusy'; 
			JCL_CmdState.cSTA_CleanPrintHeads:
				getCmdState := 'CleanPrintHeads';		
			JCL_CmdState.cSTA_CalibrationBusy:
				getCmdState := 'CalibrationBusy';	
			JCL_CmdState.cSTA_Calibration:
				getCmdState := 'Calibration';	
			JCL_CmdState.cSTA_MANUALMODE:
				getCmdState := 'Jetter Manual';	
						
			// Sub states
			JCL_CmdState.cSUB_WaitingForConnection:
				getCmdState := 'WaitingForConnection';
			JCL_CmdState.cSUB_WaitingForState:
				getCmdState := 'WaitingForState';
			JCL_CmdState.cSUB_Done:
				getCmdState := 'Done';			
			JCL_CmdState.cSUB_WaitForCleaningToStart:
				getCmdState := 'WaitForCleaningToStart';
			JCL_CmdState.cSUB_CleaningBusy:
				getCmdState := 'CleaningBusy';			
		END_CASE;
	END_IF 
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBY" Id="{20cd81fb-31ab-45dd-9818-931aceaa8cde}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_STANDBY'}
METHOD PROTECTED sta_STANDBY : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF
			BASE_PLC.cCMD_RUN:
				me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
			JCL_CmdState.cCMD_Standby:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			JCL_CmdState.cCMD_CleanPrintHeads: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
			JCL_CmdState.cCMD_Calibration: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CalibrationBusy;	
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CALIBRATIONBusy" Id="{215d7c52-60ff-4e49-8249-cfcd7b9cdf75}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CALIBRATIONBusy'}
METHOD PROTECTED sta_CALIBRATIONBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdCALIBRATION();
		END_IF
		
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_Calibration;
			END_IF
		END_IF	
	
		// Wait for feedback -> maintenance automatic done	
		IF (SIf.Cur.intJETState = JCL_CmdState.cSTA_Calibration) THEN
			me.StateMachine.intStateNext := JCL_CmdState.cSTA_Calibration;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

		
	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdCLEAN" Id="{37269112-d47b-44f7-a938-fa87b12e6c04}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdCLEAN'}
METHOD PROTECTED cmdCLEAN : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for CLEAN
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_CleanPrintHeads;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{3984e3ad-fd0b-4758-99cb-1536f1c071ae}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CtrlInit'}
METHOD CtrlInit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// one time first cyclic call!
// Open the TCP communication to jetter remote server to get the actual machine state
me.StateMachine.intStateNext := JCL_CmdState.cSTA_ConnectBusy;

// get child if
pTCP_CIF 	:= AddChild(p_fbTCP^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{3b232af6-35f9-49e1-a2dc-4a82db466da5}">
      <Declaration><![CDATA[{attribute 'object_name' := 'Always'}
METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// not inherite from base !!!  special behaviour for this controller
// SUPER^.Always();

// Conditions Always
IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	//me.StateMachine.intStateNext := cSTA_OFFBusy;
	me.bolChangeBackToAUTO := FALSE;
END_IF

IF (CIf.SwCfg.bolExist=FALSE) THEN // hardware of controller does not exist
	me.StateMachine.intStateNext := cSTA_SINGLE_ANSWER;
ELSE
	// Handle command PON
	IF (me.intCmd=cCMD_PON) 
		AND (me.StateMachine.intState<>cSTA_PONBusy) AND (me.StateMachine.intState<>cSTA_PON)
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy) THEN
		me.StateMachine.intStateNext := cSTA_PONBusy;
	ELSIF (me.intCmd=cCMD_OFF) 
		AND (me.StateMachine.intState<>cSTA_PONBusy) AND (me.StateMachine.intState<>cSTA_PON)
		AND (me.StateMachine.intState<>cSTA_OFFBusy) AND (me.StateMachine.intState<>cSTA_OFF)
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)
		AND (me.StateMachine.intState<>JCL_CmdState.cSTA_MANUALMODE) THEN
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF
		
// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// Always handle recieve data from jetter server
	IF NOT CIf.SwCfg.bolSimulation THEN
		THIS^.HandleReceiveData();
	END_IF
	
	// Request state
	// ------------------------------
	IF (me.intCmd=cCMD_RequestState) THEN
		// Request state one time
		CIf.Job.intACmd := Base_PLC.cCMD_DONE;
		CIf.Job.intMCmd := Base_PLC.cCMD_DONE;
		THIS^.RequestState();
	END_IF
	
	// Reset Jetter alarms
	// ------------------------------
	// Can be done over command "cCMD_ResetAlarm" or normal global AlmReset
	IF (me.intCmd=cCMD_ResetAlarm) OR ((CIf.Job.bolAlmReset = TRUE) AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit)) THEN
		CIf.Job.bolAlmReset := FALSE;
		IF (me.intCmd=cCMD_ResetAlarm) THEN
			CIf.Job.intACmd := Base_PLC.cCMD_DONE;
			CIf.Job.intMCmd := Base_PLC.cCMD_DONE;
		END_IF
		// Reset Jetter alarms one time
		THIS^.ResetAlarms();
	END_IF
	
	// EOFF and MANUAL
	IF (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy) AND (me.StateMachine.intState>cSTA_PON)
	  AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit)  THEN
		IF (SIf.Cur.intJETState = cSTA_EOFF) OR (SIf.Cur.intJETState = cSTA_EOFFBusy) THEN
			me.StateMachine.intStateNext := cSTA_EOFFBusy;
		ELSIF (SIf.Cur.bolIsLocalControlled) AND (me.StateMachine.intState<>cSTA_MANUALMODE) AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) THEN
			me.StateMachine.intStateNext := cSTA_MANUALMODE;
		END_IF
	END_IF
		
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{3cfe4e03-a0ba-4779-989d-5a957a9a6f6f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCtrlSIf'}
METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_JCL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdOFF" Id="{3f562f1f-c57b-4505-a237-4cf35de07f98}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdOFF'}
METHOD PROTECTED cmdOFF : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for OFF
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Off;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{400b737c-3ff0-4df2-be12-271bc46cbb0e}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUNBusy'}
METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF CIf.SwCfg.bolSimulation THEN
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= TRUE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := cSTA_RUN;
		ELSE
			cmdRUN();
		END_IF
			 
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Wait for feedback -> RUN
		IF (SIf.Cur.intJETState = cSTA_RUN) THEN
			me.StateMachine.intStateNext := BASE_PLC.cSTA_RUN;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdPON" Id="{4910a64b-c16d-41c2-8e51-4076d3eb2c20}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdPON'}
METHOD PROTECTED cmdPON : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for PON
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_PowerOn;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{50117964-48be-4c2c-9ef9-fde32862f7a3}">
      <Declaration><![CDATA[{attribute 'object_name' := 'StateMachine'}
METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	JCL_CmdState.cSTA_ConnectBusy: 
        THIS^.sta_CONNECTBusy();
	cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
	cSTA_RUN: 
        THIS^.sta_RUN();
	JCL_CmdState.cSTA_StandbyBusy: 
        THIS^.sta_STANDBYBusy();
	JCL_CmdState.cSTA_Standby: 
        THIS^.sta_STANDBY();	
	JCL_CmdState.cSTA_CleanPrintHeadsBusy: 
        THIS^.sta_CLEANINGBusy();
	JCL_CmdState.cSTA_CleanPrintHeads: 
        THIS^.sta_CLEANING();	
	JCL_CmdState.cSTA_CalibrationBusy:
		THIS^.sta_CALIBRATIONBusy();
	JCL_CmdState.cSTA_Calibration:
		THIS^.sta_CALIBRATION();
	JCL_CmdState.cSTA_MANUALMODE:
		THIS^.sta_MANUALMODE();
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBYBusy" Id="{522b5dac-2bec-4d60-82a6-84be59499724}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_STANDBYBusy'}
METHOD PROTECTED sta_STANDBYBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdSTANDBY();
		END_IF
		
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.bolReadyForProduction:= TRUE;			
				SIf.Cur.bolRunning:= TRUE;		
				SIf.Cur.bolNeedsAttention:= FALSE;			
				SIf.Cur.bolError:= FALSE;			
				SIf.Cur.bolCleaningIncomplete:= FALSE;			
				SIf.Cur.bolIsLocalControlled:= FALSE;		
				SIf.Cur.bolIsRemoteControlled:= TRUE;
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_Standby;
			END_IF
		END_IF	
	
		// Wait for feedback -> standby	
		IF (SIf.Cur.intJETState  = JCL_CmdState.cSTA_Standby) THEN
			me.StateMachine.intStateNext := JCL_CmdState.cSTA_Standby;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAlarms" Id="{523828ca-e66b-4e66-aca9-a1978134204f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'ResetAlarms'}
METHOD PROTECTED ResetAlarms : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Request jetter state
IF NOT (CIf.SwCfg.bolSimulation) THEN
	stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
	stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
	stNextCommand.usiCommand := JCL_CMD_ResetAlarm;
	pNextCommand := ADR(stNextCommand);	
	p_fbTCP^.M_Push(paPushMsg := pNextCommand);		
END_IF	]]></ST>
      </Implementation>
    </Method>
    <Property Name="TCP" Id="{53ad2fcf-4990-4851-9daa-e06c42c805ad}">
      <Declaration><![CDATA[PROPERTY TCP : POINTER TO FB_TCP
]]></Declaration>
      <Set Name="Set" Id="{13572306-d1cd-47f4-b167-57a93c06f9ea}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[p_fbTCP := TCP;]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{39a997d7-d3f1-441f-a991-434d6c7bba37}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[TCP := p_fbTCP;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="sta_ERROR" Id="{747b1401-aca2-4ba7-a930-010ee7b3af8d}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERROR'}
METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

	
// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_MANUALMODE" Id="{76b332f9-f785-49bb-907d-2313c08a976a}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_MANUALMODE'}
METHOD PROTECTED sta_MANUALMODE : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle;
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		SIf.Cur.bolNeedsCleaning := FALSE;
		
		// set Warning
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualWarning,0,ADR(SIf.Alm),E_AlmState.SET,CIf.Job.eMe_ActivAlmClass);
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		IF SIf.Cfg.bolJetterManualModeAllowed THEN
			IF SIf.Cur.bolIsRemoteControlled THEN
				me.StateMachine.intStateNext := cSTA_OFFBusy;
			END_IF
		ELSE
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		
		// clear Warning
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualWarning,0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
		
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFFBusy" Id="{818a99fe-f7cd-407e-8df5-46c12f8f7fdf}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_EOFFBusy'}
METHOD PROTECTED sta_EOFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterEOff,0,ADR(SIf.Alm),E_AlmState.SET,CIf.Job.eMe_ActivAlmClass);
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateNext := cSTA_EOFF;
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildAlmClass" Id="{819eee58-60b0-4040-9ab0-772f01f0e5ee}">
      <Declaration><![CDATA[{attribute 'object_name' := 'checkChildAlmClass'}
METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// If there is a TCP connection problem to the server
IF (pTCP_CIF^.Job.eMe_ActivAlmClass >= E_AlmClass.TSTOP) THEN
	bolServerConnectionError:= TRUE;
	// set me alarm class OFF
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CLEANING" Id="{91e22eed-8133-4e1e-a7a2-a2ec2d9086fe}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CLEANING'}
METHOD PROTECTED sta_CLEANING : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

		SIf.Cur.bolNeedsCleaning:= FALSE;			
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF	
			Base_PLC.cCMD_RUN:
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;	
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;			
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CLEANINGBusy" Id="{95a1d77f-d2a5-41b0-867b-84981014c697}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CLEANINGBusy'}
METHOD PROTECTED sta_CLEANINGBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdCLEAN();
		END_IF

		me.SubStateMachine.intState := cSUB_WaitForCleaningToStart;		
		me.SubStateMachine.intStateNext := cSUB_WaitForCleaningToStart;		
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_CleanPrintHeads;
			END_IF
		END_IF	
		
		CASE me.SubStateMachine.intState OF
			cSUB_WaitForCleaningToStart:
				IF SIf.Cur.intJETState = cSTA_CleanPrintHeadsBusy THEN
					me.SubStateMachine.intStateNext := cSUB_CleaningBusy;
				END_IF
				
				IF me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiCleaningStartTimeout_ms THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.CleaningError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
				END_IF
			cSUB_CleaningBusy:
				// Wait for feedback -> maintenance automatic done	
				IF (SIf.Cur.intJETState = JCL_CmdState.cSTA_CleanPrintHeads) THEN
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeads;
				END_IF
		END_CASE
		
		IF SIf.Cur.intJETState = cSTA_ERROR THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.CleaningError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.SubStateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF
	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdCALIBRATION" Id="{af381e68-21e4-4a0f-84ab-f0d6eb1b62be}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdCALIBRATION'}
METHOD PROTECTED cmdCALIBRATION : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for CALIBRATION
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Calibration;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFF" Id="{b0797c18-58e5-4371-95e9-7af90cf30485}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_EOFF'}
METHOD PROTECTED sta_EOFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		IF (SIf.Cur.intJETState <> cSTA_EOFF) AND (SIf.Cur.intJETState <> cSTA_EOFFBusy) THEN
			IF SIf.Cur.bolIsLocalControlled THEN
				me.StateMachine.intStateNext := cSTA_MANUALMODE;
			ELSE
				me.StateMachine.intStateNext := cSTA_OFFBusy;
			END_IF
		END_IF
		
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterEOff,0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERRORQuit" Id="{b0a55935-cf49-4805-9743-d0c7063d0cd6}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERRORQuit'}
METHOD PROTECTED sta_ERRORQuit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// evtl. wait time if reset of device is necessary and then decide to go to states or ERROR state
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
			CIf.Job.bolAlmReset := FALSE;
		END_IF
		
		// State Change Condition
		IF (pTCP_CIF^.Job.bolAlmReset = FALSE) THEN
			IF pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect THEN
				IF SIf.Cfg.bolJetterManualModeAllowed THEN
					IF SIf.Cur.bolIsLocalControlled THEN
						me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
					ELSE
						me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
					END_IF
				ELSE
					IF SIf.Cur.bolIsLocalControlled THEN
						me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
					ELSE
						me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
					END_IF
				END_IF
			ELSE
				// If the error was triggered because of an TCP connection problem to the server
				IF (bolServerConnectionError) AND (pTCP_CIF^.Job.eMe_ActivAlmClass = E_AlmClass.NONE) THEN
					bolServerConnectionError:= FALSE;
					// Try to reopen the connection to server
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_ConnectBusy;
				END_IF
			END_IF
		END_IF
	END_IF

	
// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{b56143c5-e3a2-4770-afaf-a00a7b5092b7}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PON'}
METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF
	

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN	
		
		IF (SIf.Cur.intJETState = cSTA_EOFF) OR (SIf.Cur.intJETState = cSTA_EOFFBusy) THEN
			me.StateMachine.intStateNext := cSTA_EOFFBusy;
		ELSIF SIf.Cur.bolIsLocalControlled THEN
			me.StateMachine.intStateNext := cSTA_MANUALMODE;
		ELSE
			me.StateMachine.intStateNext := cSTA_OFFBusy;
		END_IF
	
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{b6216a7c-7773-4657-a8e2-f311423b3115}">
      <Declaration><![CDATA[{attribute 'object_name' := 'FB_init'}
METHOD FB_init : BOOL
VAR_INPUT
	/// if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	/// if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	iIdx: UINT;
	iLength: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
iLength := SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0]);
iIdx := 0;

WHILE (iIdx < iLength) AND (CIf.Job.aCmdList[iIdx].intCmd <> cCMD_INITIALIZED) DO
	iIdx := iIdx + 1; 
END_WHILE

IF (iIdx < iLength) THEN
// Add configuration of own comands	
	CIf.Job.aCmdList[iIdx].intCmd := BASE_PLC.cCMD_RUN;
	CIf.Job.aCmdList[iIdx].strName := 'RUN'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
    iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_Standby;
	CIf.Job.aCmdList[iIdx].strName := 'STANDBY'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_CleanPrintHeads;
	CIf.Job.aCmdList[iIdx].strName := 'CLEANING'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_Calibration;
	CIf.Job.aCmdList[iIdx].strName := 'CALIBRATION'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_ResetAlarm;
	CIf.Job.aCmdList[iIdx].strName := 'RESET ALARM'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_RequestState;
	CIf.Job.aCmdList[iIdx].strName := 'REQUEST STATE'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
ELSE
	// Error if the aCmdList Array is to small
END_IF

// set name of class/typ
CIf.Info.strType := 'FB_JCL';
CIf.Info.strFullName := 'Jetter Client';

// set alarm class
SIf.Alm[E_ALM_JCL.JetterNotRun].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterNotRun].strText := 'Jetter is not in RUN';
SIf.Alm[E_ALM_JCL.JetterManualWarning].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[E_ALM_JCL.JetterManualWarning].strText := 'Manual Operation';
SIf.Alm[E_ALM_JCL.JetterManualError].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterManualError].strText := 'Manual Operation';
SIf.Alm[E_ALM_JCL.JetterEOff].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterEOff].strText := 'Jetter in EOFF';
SIf.Alm[E_ALM_JCL.JetterCommunicationLost].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterCommunicationLost].strText := 'Jetter Communication Lost';
SIf.Alm[E_ALM_JCL.CleaningError].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.CleaningError].strText := 'Cleaning Error';
SIf.Alm[E_ALM_JCL.DataChannelFull].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.DataChannelFull].strText := 'Print Done DataChannel Buffer is full';


// *******************************************************************************
// initial values
// *******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolEnable := TRUE;
CIf.SwCfg.bolSimulation :=  FALSE;

// Fill the lookup table with all valid jetter states
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_EOFFBusy, iAddValue:= 3);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_EOFF, iAddValue:= 4);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_PONBusy, iAddValue:= 1);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_PON, iAddValue:= 2);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_OFFBusy, iAddValue:= 5);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_OFF, iAddValue:= 6);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_ParkBusy, iAddValue:= 211);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_INITBusy, iAddValue:= 7);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_INIT, iAddValue:= 8);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_StandbyBusy, iAddValue:= 201);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_Standby, iAddValue:= 202);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_RUNBusy, iAddValue:= 9);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_RUN, iAddValue:= 10);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CalibrationBusy, iAddValue:= 203);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_Calibration, iAddValue:= 204);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CleanPrintHeadsBusy, iAddValue:= 205);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CleanPrintHeads, iAddValue:= 206);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceBusy, iAddValue:= 208);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceInWork, iAddValue:= 209);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceDone, iAddValue:= 210);

SIf.Par.udiCleaningStartTimeout_ms := 5000;

SIf.Cur.bolNeedsCleaning:= FALSE;	
SIf.Cur.intJETState:= 0;  // current state not yet known
SIf.Cfg.bolJetterManualModeAllowed := FALSE;
SIf.Cfg.bolEnablePrintDoneDataChannel := FALSE;

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdRUN" Id="{b747f499-7aa8-41ab-a7d4-64b91bac84f3}">
      <Declaration><![CDATA[{attribute 'object_name' := 'cmdRUN'}
METHOD PROTECTED cmdRUN : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for RUN
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Run;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="msg_HandleCleaningDone" Id="{b7872fa6-578f-4e03-b033-bb213e07e2b3}">
      <Declaration><![CDATA[METHOD PROTECTED msg_HandleCleaningDone : BOOL
VAR_INPUT
	pMessage			: POINTER TO U_JCL_Message;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMessage <> NULL THEN
	SIf.Cur.bolNeedsCleaning:= FALSE;			
	SIf.Cur.strDTOfLastCleaningCycle:= pMessage^.CleaningDone.strDTLastClean;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="BarcodeArrayToUdint" Id="{bc7a4599-2f78-4c3d-81cc-2ce71562ea96}">
      <Declaration><![CDATA[METHOD PROTECTED BarcodeArrayToUdint : UDINT
VAR_INPUT
	aBarcode 		: ARRAY[0..9] OF USINT;
END_VAR
VAR
	iIdx			: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BarcodeArrayToUdint := 0;

FOR iIdx := 0 TO 9 DO
	BarcodeArrayToUdint := BarcodeArrayToUdint * 10 + aBarcode[iIdx];	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="msg_HandleCleaningRequest" Id="{c07cef22-c01b-4b71-9572-ab3b76f51a51}">
      <Declaration><![CDATA[METHOD PROTECTED msg_HandleCleaningRequest : BOOL
VAR_INPUT
	pMessage			: POINTER TO U_JCL_Message;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMessage <> NULL THEN
	SIf.Cur.bolNeedsCleaning:= TRUE;			
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="RequestState" Id="{caced97f-7ec1-4a22-8040-51aeedebce88}">
      <Declaration><![CDATA[{attribute 'object_name' := 'RequestState'}
METHOD PROTECTED RequestState : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Request jetter state
IF NOT (CIf.SwCfg.bolSimulation) THEN
	stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
	stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
	stNextCommand.usiCommand := JCL_CMD_RequestState;
	pNextCommand := ADR(stNextCommand);	
	p_fbTCP^.M_Push(paPushMsg := pNextCommand);		
END_IF	]]></ST>
      </Implementation>
    </Method>
    <Property Name="CtrlSIf" Id="{cd3da189-d016-4aac-9e2a-cd30f5b05374}">
      <Declaration><![CDATA[PROPERTY CtrlSIf : POINTER TO T_Ctrl_SIf_JCL
]]></Declaration>
      <Get Name="Get" Id="{463ae8d6-5141-4fdb-ad6b-6d6882df9462}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[CtrlSIf := ADR(SIf);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="sta_RUN" Id="{edb444e8-2a63-46bc-8f54-357888e6caf5}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUN'}
METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		IF (SIf.Cfg.bolJetterManualModeAllowed) THEN
			IF SIf.Cur.bolIsLocalControlled THEN
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
			END_IF			
			
			IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		ELSE
			IF (SIf.Cur.intJETState <> cSTA_RUN) THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterNotRun,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
				
			IF SIf.Cur.bolIsLocalControlled THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

		IF (me.StateMachine.intStateNext<>Base_PLC.cSTA_ERROR) AND (me.StateMachine.intStateNext<>JCL_CmdState.cSTA_MANUALMODE)THEN
			CASE me.intCmd OF
				Base_PLC.cCMD_RUN:
					me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;
				JCL_CmdState.cCMD_CleanPrintHeads:
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
				JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			END_CASE
		END_IF
		
	END_IF
	

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="msg_HandlePrintDone" Id="{ee963a43-8a11-44e3-b89f-a5912be18992}">
      <Declaration><![CDATA[METHOD PROTECTED msg_HandlePrintDone : BOOL
VAR_INPUT
	pMessage			: POINTER TO U_JCL_Message;
END_VAR
VAR
	pItem				: POINTER TO T_JCL_DCH;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMessage <> NULL THEN
	IF SIf.Cfg.bolEnablePrintDoneDataChannel THEN
		IF m_pDataChannel <> NULL THEN
			IF UINT_TO_INT(m_pDataChannel^.ItemCount) >= m_pDataChannel^.MaxFifoSize THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.DataChannelFull,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			ELSE
				pItem := __NEW(T_JCL_DCH);
				pItem^.rBaseInfo.eHealth := E_ItemHealth.Healthy;
				pItem^.rBaseInfo.uinModuleId := 16;
				pItem^.rBaseInfo.uinActualPosition := 1;
				pItem^.udiIdentification := BarcodeArrayToUdint(pMessage^.PrintDone.usiBarcode);
				MEMCPY(ADR(pItem^.udiInkMeniscus[0]), ADR(pMessage^.PrintDone.udiInkMeniscus[0]),SIZEOF(pItem^.udiInkMeniscus)*2);
				MEMCPY(ADR(pItem^.udiPrintHeadTemperatureModule1[0]), ADR(pMessage^.PrintDone.udiPrintHeadTemperature[0,0]),SIZEOF(pItem^.udiPrintHeadTemperatureModule1[0])*5);
				MEMCPY(ADR(pItem^.udiPrintHeadTemperatureModule1[0]), ADR(pMessage^.PrintDone.udiPrintHeadTemperature[1,0]),SIZEOF(pItem^.udiPrintHeadTemperatureModule1[0])*5);
				pItem^.udiPrintLengthCalc := pMessage^.PrintDone.udiPrintLengthCalc;
				pItem^.udiPrintWidthCalc := pMessage^.PrintDone.udiPrintWidthCalc;
				pItem^.udiShiftAngleCalc := pMessage^.PrintDone.udiShiftAngleCalc;
				pItem^.udiShiftXCalc := pMessage^.PrintDone.udiShiftXCalc;
				pItem^.udiShiftYCalc := pMessage^.PrintDone.udiShiftYCalc;
				pItem^.usiInkLevelMainTank := pMessage^.PrintDone.usiInkLevelMainTank;
				pItem^.usiInkLevelReturnPrintModule1 := pMessage^.PrintDone.usiInkLevelReturnPrintModule1;
				pItem^.usiInkLevelReturnPrintModule2 := pMessage^.PrintDone.usiInkLevelReturnPrintModule2;
				pItem^.usiInkLevelSupplyPrintModule1 := pMessage^.PrintDone.usiInkLevelSupplyPrintModule1;
				pItem^.usiInkLevelSupplyPrintModule2 := pMessage^.PrintDone.usiInkLevelSupplyPrintModule2;
				m_pDataChannel^.Push(pItem);					
			END_IF
		END_IF
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CONNECTBusy" Id="{f50874c3-c4c7-4d01-a2dc-39a46f8d2395}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CONNECTBusy'}
METHOD sta_CONNECTBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	
		// **********************************************************************************
		// This state will be executed one time after startup or after an error ack.
		// State open the TCP communication to jetter remote server to get the actual machine state
		// **********************************************************************************
		// Reset state 
		SIf.Cur.intJETState:= 0;
		
		// Connect to the jetter server
		pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;
		
		// Initialize sub state machine
		me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;		
		me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// -----------------------------------------------
		// Sub state machine handle 
		// -----------------------------------------------
		CASE me.SubStateMachine.intState OF
			
			JCL_CmdState.cSUB_WaitingForConnection:			
				// Wait for connection
				IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) THEN	
					// Request jetter states the first time after TCP client connected				
					THIS^.RequestState();		
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForState;	
				END_IF
			
			JCL_CmdState.cSUB_WaitingForState:
				// Wait for first status msg 
				IF (SIf.Cur.intJETState > 0) THEN 
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_Done;
				END_IF	

			JCL_CmdState.cSUB_Done:
				// Change to the init state
				me.StateMachine.intStateNext := SIf.Cur.intJETState;
			
		END_CASE
			
	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{f6616b0e-eba7-488f-a117-55b54cf92e7f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFFBusy'}
METHOD PROTECTED sta_OFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF (CIf.SwCfg.bolSimulation) THEN 
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= FALSE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := BASE_PLC.cSTA_OFF;
		ELSE 
			SIf.Cur.bolNeedsCleaning := FALSE;
			cmdOFF();
		END_IF
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Wait for feedback -> OFF
		IF (SIf.Cur.intJETState = BASE_PLC.cSTA_OFF) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="DataChannel" Id="{f80947bf-336b-40ee-a6db-3cc864449d89}">
      <Declaration><![CDATA[PROPERTY DataChannel : POINTER TO FB_DataChannelSenderFifo
]]></Declaration>
      <Set Name="Set" Id="{663ca45c-8fab-4d83-8aa8-d6fc472825e5}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_pDataChannel := DataChannel;]]></ST>
        </Implementation>
      </Set>
    </Property>
  </POU>
</TcPlcObject>