<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.26">
  <POU Name="FB_JCL" Id="{5617b180-9b4d-4b3a-9d6c-40be2041283c}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_JCL EXTENDS FB_CtrlBase
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_JCL;
	/// pointer to function block
	p_fbTCP: POINTER TO FB_TCP;
	pTCP_CIF: POINTER TO BASE_PLC.T_Ctrl_CIf;
	fbStateLookup: FB_LookupTable;
	fbCommandLookup: FB_LookupTable;
	bolServerConnectionError: BOOL;
	/// variables for receiving msgs
	m_naNextMsg: ARRAY[0..MAX_DATASET_SIZE] OF BYTE;
	m_paNextMsg: POINTER TO ARRAY[0..MAX_DATASET_SIZE] OF BYTE;
	m_puNextMsg: POINTER TO U_JCL_Message;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
ToDo: DSC...

History:
Version		Date			Author				Comment
---------------------------------------------------------------------------------------------------
0.00.1		20.05.2014		AVME/DSC			Start history. Insert all basic functionalities.
___________________________________________________________________________________________________*)

SUPER^();]]></ST>
    </Implementation>
    <Method Name="sta_CALIBRATION" Id="{06b15162-9b36-42bd-b180-bda701ad868c}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CALIBRATION'}
METHOD PROTECTED sta_CALIBRATION : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF		
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;			
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleReceiveData" Id="{14886497-9176-40e4-9628-33e3ecb94a1c}">
      <Declaration><![CDATA[{attribute 'object_name' := 'HandleReceiveData'}
METHOD HandleReceiveData
VAR
	bPop: BOOL;
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// get next message
p_fbTCP^.M_Pop(naPopMsg => m_naNextMsg, bPop => bPop);

IF bPop THEN // something has been recieved
	CASE m_puNextMsg^.State.stHeader.uinMsgId OF

		// -----------------------------------------------
		// Handle received state
		// -----------------------------------------------
		// Note: The Status is send on Request and on Status Change
		JCL_MsgId_State:
			
			// Update the main state
			fbStateLookup.A_LookupByValue(iLookupValue := m_puNextMsg^.State.usiMainState, iFoundKey => SIf.Cur.intJETState);
	
			// Prepare additional states
			(*
			State				BIT		Description
			-------------------------------------------------------------------------------------------------
			ReadyForProduction	0		Jetter ready for production
			Running				1		Print running, in production
			NeedsAttention		2		System needs attention. Info or warning active
			Error				3		General error active
			CleaningIncomplete	4		Cleaning cycle was aborted before finishing. Production not possible.
			 -					5	 	-
			IsLocalControlled	6		Local control active. Commands from Client are ignored
			IsRemoteControlled	7		Remote control active. Commands from Client are accepted
			*)
	
			SIf.Cur.bolReadyForProduction:= m_puNextMsg^.State.usiAddState.0;			
			SIf.Cur.bolRunning:= m_puNextMsg^.State.usiAddState.1;		
			SIf.Cur.bolNeedsAttention:= m_puNextMsg^.State.usiAddState.2;			
			SIf.Cur.bolError:= m_puNextMsg^.State.usiAddState.3;			
			SIf.Cur.bolCleaningIncomplete:= m_puNextMsg^.State.usiAddState.4;			
			SIf.Cur.bolIsLocalControlled:= m_puNextMsg^.State.usiAddState.6;		
			SIf.Cur.bolIsRemoteControlled:= m_puNextMsg^.State.usiAddState.7;
			
		// -----------------------------------------------
		// Handle received print info (print done)
		// -----------------------------------------------		
		JCL_MsgId_PrintDone:
			;
		
		// -----------------------------------------------
		// Handle received alarm message
		// -----------------------------------------------
		JCL_MsgId_Alarm:
			;
			
		// -----------------------------------------------
		// Handle received request for cleaning
		// -----------------------------------------------
		JCL_MsgId_ReqCleaning:
				
			SIf.Cur.bolNeedsCleaning:= TRUE;			
			SIf.Cur.strDTOfLastCleaningCycle:= m_puNextMsg^.ReqCleaning.strDTLastClean;
		
		// nothing received	
		0:
			; 
	ELSE
		; // To do: Add error	
	END_CASE
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdSTANDBY" Id="{1b4947a0-f41a-4520-b259-b616a5cd0946}">
      <Declaration><![CDATA[METHOD PROTECTED cmdSTANDBY : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for STANDBY
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Standby;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFF" Id="{1d5cec0d-4d2a-491c-b4e6-7f9086bcb77f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFF'}
METHOD PROTECTED sta_EOFF : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		IF (SIf.Cur.intJETState <> cSTA_EOFF) AND (SIf.Cur.intJETState <> cSTA_EOFFBusy) THEN
			IF SIf.Cur.bolIsLocalControlled THEN
				me.StateMachine.intStateNext := cSTA_MANUALMODE;
			ELSE
				me.StateMachine.intStateNext := cSTA_OFFBusy;
			END_IF
		END_IF
		
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterEOff,0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{2694237d-33bc-49ed-a28f-b2a7d5fff52d}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUNBusy'}
METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF CIf.SwCfg.bolSimulation THEN
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= TRUE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := cSTA_RUN;
		ELSE
			cmdRUN();
		END_IF
			 
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Wait for feedback -> RUN
		IF (SIf.Cur.intJETState = cSTA_RUN) THEN
			me.StateMachine.intStateNext := BASE_PLC.cSTA_RUN;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{29d80980-b59f-4156-9c0a-5668c590a8e3}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CtrlInit'}
METHOD CtrlInit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// one time first cyclic call!
// Open the TCP communication to jetter remote server to get the actual machine state
me.StateMachine.intStateNext := JCL_CmdState.cSTA_ConnectBusy;

// get child if
pTCP_CIF 	:= AddChild(p_fbTCP^);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CLEANINGBusy" Id="{29e34ece-3c27-4d90-9fd5-fab6049792db}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CLEANINGBusy'}
METHOD PROTECTED sta_CLEANINGBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdCLEAN();
		END_IF
		
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_CleanPrintHeads;
			END_IF
		END_IF	
	
		// Wait for feedback -> maintenance automatic done	
		IF (SIf.Cur.intJETState = JCL_CmdState.cSTA_CleanPrintHeads) THEN
			me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeads;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{40d55a40-6e80-490d-8d95-b920a7fa31ab}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFF'}
METHOD PROTECTED sta_OFF : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		CASE me.intCmd OF
			Base_PLC.cCMD_RUN: 				
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;	
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			JCL_CmdState.cCMD_CleanPrintHeads: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
		END_CASE
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBY" Id="{4a9529ef-d6bd-43cf-9ed5-f5288cf07fff}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_STANDBY'}
METHOD PROTECTED sta_STANDBY : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF
			BASE_PLC.cCMD_RUN:
				me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
			JCL_CmdState.cCMD_Standby:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			JCL_CmdState.cCMD_CleanPrintHeads: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
			JCL_CmdState.cCMD_Calibration: 				
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_CalibrationBusy;	
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdCLEAN" Id="{515f0603-628d-4a59-91f4-9b76b2272831}">
      <Declaration><![CDATA[METHOD PROTECTED cmdCLEAN : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for CLEAN
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_CleanPrintHeads;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CONNECTBusy" Id="{52465829-7462-4636-aa99-a613adc547b9}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CONNECTBusy'}
METHOD sta_CONNECTBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	
		// **********************************************************************************
		// This state will be executed one time after startup or after an error ack.
		// State open the TCP communication to jetter remote server to get the actual machine state
		// **********************************************************************************
		// Reset state 
		SIf.Cur.intJETState:= 0;
		
		// Connect to the jetter server
		pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;
		
		// Initialize sub state machine
		me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;		
		me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// -----------------------------------------------
		// Sub state machine handle 
		// -----------------------------------------------
		CASE me.SubStateMachine.intState OF
			
			JCL_CmdState.cSUB_WaitingForConnection:			
				// Wait for connection
				IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) THEN	
					// Request jetter states the first time after TCP client connected				
					THIS^.RequestState();		
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForState;	
				END_IF
			
			JCL_CmdState.cSUB_WaitingForState:
				// Wait for first status msg 
				IF (SIf.Cur.intJETState > 0) THEN 
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_Done;
				END_IF	

			JCL_CmdState.cSUB_Done:
				// Change to the init state
				me.StateMachine.intStateNext := SIf.Cur.intJETState;
			
		END_CASE
			
	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PONBusy" Id="{5393620d-b342-4254-905e-b5132c7c700b}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PONBusy'}
METHOD PROTECTED sta_PONBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF NOT (CIf.SwCfg.bolSimulation) THEN
			// If the socket is already connected, trigger a reconnet.
			IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) OR (pTCP_CIF^.Job.intState = Base_PLC.cSTA_ERROR) THEN
				// Initialize sub state machine
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingSocketClosed;		
				me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
				// Connect to jetter server
				pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Close;	
			ELSE		
				// Initialize sub state machine
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;		
				me.SubStateMachine.intState:= me.SubStateMachine.intStateNext-1;
				// Connect to jetter server
				pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;	
			END_IF
		ELSE
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= FALSE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := BASE_PLC.cSTA_PON;
		END_IF
		
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.SubStateMachine.intState OF
				
			// -----------------------------------------		
			JCL_CmdState.cSUB_WaitingSocketClosed:	
				IF (CIf.SwCfg.bolSimulation) THEN
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;	
				ELSE							
					// Wait for socket closed
					IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Close) THEN			
						me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_WaitingForConnection;	
					END_IF		
				END_IF
		
			// -----------------------------------------		
			JCL_CmdState.cSUB_WaitingForConnection:		
				IF (CIf.SwCfg.bolSimulation) THEN
					me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_SendPon;	
				ELSE							
					// Connect to jetter server
					pTCP_CIF^.Job.intACmd:= TCP_CmdState.cCMD_Connect;	
						
					// Wait for connection
					IF (pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect) THEN			
						me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_SendPon;	
					END_IF		
				END_IF
			
			// -----------------------------------------		
			JCL_CmdState.cSUB_SendPon:
				IF (me.intCmd = cCMD_PON) THEN
					cmdPON();
				END_IF
				me.SubStateMachine.intStateNext:= JCL_CmdState.cSUB_Done;
						
			// -----------------------------------------		
			JCL_CmdState.cSUB_Done:
				me.StateMachine.intStateNext := cSTA_PON;
		
		END_CASE
		
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdPON" Id="{670f8d96-fd23-407a-8f15-28ce4722b2e5}">
      <Declaration><![CDATA[METHOD PROTECTED cmdPON : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for PON
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_PowerOn;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildAlmClass" Id="{6df74c03-338a-4fe3-be56-a6b61617ca22}">
      <Declaration><![CDATA[{attribute 'object_name' := 'checkChildAlmClass'}
METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// If there is a TCP connection problem to the server
IF (pTCP_CIF^.Job.eMe_ActivAlmClass >= E_AlmClass.TSTOP) THEN
	bolServerConnectionError:= TRUE;
	// set me alarm class OFF
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBYBusy" Id="{6f3177fc-750e-4d24-8768-1e6e3ed85167}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_STANDBYBusy'}
METHOD PROTECTED sta_STANDBYBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdSTANDBY();
		END_IF
		
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.bolReadyForProduction:= TRUE;			
				SIf.Cur.bolRunning:= TRUE;		
				SIf.Cur.bolNeedsAttention:= FALSE;			
				SIf.Cur.bolError:= FALSE;			
				SIf.Cur.bolCleaningIncomplete:= FALSE;			
				SIf.Cur.bolIsLocalControlled:= FALSE;		
				SIf.Cur.bolIsRemoteControlled:= TRUE;
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_Standby;
			END_IF
		END_IF	
	
		// Wait for feedback -> standby	
		IF (SIf.Cur.intJETState  = JCL_CmdState.cSTA_Standby) THEN
			me.StateMachine.intStateNext := JCL_CmdState.cSTA_Standby;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{70ffa97f-f14d-4f56-abac-da5fee702602}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFFBusy'}
METHOD PROTECTED sta_OFFBusy : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF (CIf.SwCfg.bolSimulation) THEN 
			SIf.Cur.bolReadyForProduction:= TRUE;			
			SIf.Cur.bolRunning:= FALSE;		
			SIf.Cur.bolNeedsAttention:= FALSE;			
			SIf.Cur.bolError:= FALSE;			
			SIf.Cur.bolCleaningIncomplete:= FALSE;			
			SIf.Cur.bolIsLocalControlled:= FALSE;		
			SIf.Cur.bolIsRemoteControlled:= TRUE;
			SIf.Cur.intJETState := BASE_PLC.cSTA_OFF;
		ELSE 
			cmdOFF();
		END_IF
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Wait for feedback -> OFF
		IF (SIf.Cur.intJETState = BASE_PLC.cSTA_OFF) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="TCP" Id="{84bc78df-7dc4-493d-b729-20a9c886d4bc}">
      <Declaration><![CDATA[PROPERTY TCP : POINTER TO FB_TCP
]]></Declaration>
      <Get Name="Get" Id="{b4b9c019-d93f-46b5-b856-917b82aa4ef1}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[TCP := p_fbTCP;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{d0026357-782d-460c-98a2-bb7489a77bea}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[p_fbTCP := TCP;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="StateMachine" Id="{89f0039a-3a5a-406f-829c-ecdf7e794ca5}">
      <Declaration><![CDATA[{attribute 'object_name' := 'StateMachine'}
METHOD PROTECTED StateMachine : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	JCL_CmdState.cSTA_ConnectBusy: 
        THIS^.sta_CONNECTBusy();
	cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
	cSTA_RUN: 
        THIS^.sta_RUN();
	JCL_CmdState.cSTA_StandbyBusy: 
        THIS^.sta_STANDBYBusy();
	JCL_CmdState.cSTA_Standby: 
        THIS^.sta_STANDBY();	
	JCL_CmdState.cSTA_CleanPrintHeadsBusy: 
        THIS^.sta_CLEANINGBusy();
	JCL_CmdState.cSTA_CleanPrintHeads: 
        THIS^.sta_CLEANING();	
	JCL_CmdState.cSTA_CalibrationBusy:
		THIS^.sta_CALIBRATIONBusy();
	JCL_CmdState.cSTA_Calibration:
		THIS^.sta_CALIBRATION();
	JCL_CmdState.cSTA_MANUALMODE:
		THIS^.sta_MANUALMODE();
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdRUN" Id="{8a3ee2e2-7aa3-40e5-901b-fd427919bcb2}">
      <Declaration><![CDATA[METHOD PROTECTED cmdRUN : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for RUN
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Run;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdOFF" Id="{97b7d48d-fa1c-41e2-acc7-609182329400}">
      <Declaration><![CDATA[METHOD PROTECTED cmdOFF : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for OFF
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Off;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CALIBRATIONBusy" Id="{9be5ba67-7610-4700-8f21-a4100b3b90f0}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CALIBRATIONBusy'}
METHOD PROTECTED sta_CALIBRATIONBusy : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := T#5S;
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
				
		IF CIf.SwCfg.bolSimulation THEN
			;
		ELSE
			cmdCALIBRATION();
		END_IF
		
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.intJETState  := JCL_CmdState.cSTA_Calibration;
			END_IF
		END_IF	
	
		// Wait for feedback -> maintenance automatic done	
		IF (SIf.Cur.intJETState = JCL_CmdState.cSTA_Calibration) THEN
			me.StateMachine.intStateNext := JCL_CmdState.cSTA_Calibration;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

		
	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{9e6ff1cd-668f-43fa-9ce4-4de61bb7e9a5}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERROR'}
METHOD PROTECTED sta_ERROR : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

	
// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERRORQuit" Id="{a93174c2-3bd8-4eca-a524-2bfb42fe33b6}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERRORQuit'}
METHOD PROTECTED sta_ERRORQuit : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// evtl. wait time if reset of device is necessary and then decide to go to states or ERROR state
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
			CIf.Job.bolAlmReset := FALSE;
		END_IF
		
		// State Change Condition
		IF (pTCP_CIF^.Job.bolAlmReset = FALSE) THEN
			IF pTCP_CIF^.Job.intState = TCP_CmdState.cSTA_Connect THEN
				IF SIf.Cfg.bolJetterManualModeAllowed THEN
					IF SIf.Cur.bolIsLocalControlled THEN
						me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
					ELSE
						me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
					END_IF
				ELSE
					IF SIf.Cur.bolIsLocalControlled THEN
						me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
					ELSE
						me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
					END_IF
				END_IF
			ELSE
				// If the error was triggered because of an TCP connection problem to the server
				IF (bolServerConnectionError) AND (pTCP_CIF^.Job.eMe_ActivAlmClass = E_AlmClass.NONE) THEN
					bolServerConnectionError:= FALSE;
					// Try to reopen the connection to server
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_ConnectBusy;
				END_IF
			END_IF
		END_IF
	END_IF

	
// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFFBusy" Id="{aa90dd16-ec32-40a4-8fee-f8d55dfeb10a}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFFBusy'}
METHOD PROTECTED sta_EOFFBusy : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterEOff,0,ADR(SIf.Alm),E_AlmState.SET,CIf.Job.eMe_ActivAlmClass);
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateNext := cSTA_EOFF;
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{b3cc9bf7-e773-4c3a-8b67-b308a78d8947}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCtrlSIf'}
METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_JCL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{b444cd0e-2d29-40aa-8958-478b9b426456}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCmdState'}
METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states

IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime	
	IF (bolState=FALSE) THEN
		// States's
		CASE intCmdState OF
			JCL_CmdState.cCMD_Standby: 
				getCmdState := 'Standby';
			JCL_CmdState.cCMD_CleanPrintHeads: 
				getCmdState := 'CleanPrintHeads';		
				
		END_CASE;
	ELSE
		// States's
		CASE intCmdState OF			
			// Main states
			JCL_CmdState.cSTA_StandbyBusy: 
				getCmdState := 'StandbyBusy'; 
			JCL_CmdState.cSTA_Standby:
				getCmdState := 'Standby';			
			JCL_CmdState.cSTA_ConnectBusy:
				getCmdState := 'ConnectBusy';
			JCL_CmdState.cSTA_CleanPrintHeadsBusy: 
				getCmdState := 'CleanPrintHeadsBusy'; 
			JCL_CmdState.cSTA_CleanPrintHeads:
				getCmdState := 'CleanPrintHeads';		
			JCL_CmdState.cSTA_CalibrationBusy:
				getCmdState := 'CalibrationBusy';	
			JCL_CmdState.cSTA_Calibration:
				getCmdState := 'Calibration';	
			JCL_CmdState.cSTA_MANUALMODE:
				getCmdState := 'Jetter Manual';	
						
			// Sub states
			JCL_CmdState.cSUB_WaitingForConnection:
				getCmdState := 'WaitingForConnection';
			JCL_CmdState.cSUB_WaitingForState:
				getCmdState := 'WaitingForState';
			JCL_CmdState.cSUB_Done:
				getCmdState := 'Done';			
		END_CASE;
	END_IF 
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="RequestState" Id="{c35cf892-47c2-442d-a9da-180fe616e141}">
      <Declaration><![CDATA[{attribute 'object_name' := 'RequestState'}
METHOD PROTECTED RequestState : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Request jetter state
IF NOT (CIf.SwCfg.bolSimulation) THEN
	stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
	stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
	stNextCommand.usiCommand := JCL_CMD_RequestState;
	pNextCommand := ADR(stNextCommand);	
	p_fbTCP^.M_Push(paPushMsg := pNextCommand);		
END_IF	]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{c859cf02-60cc-4c4c-876a-145b458b8fa4}">
      <Declaration><![CDATA[{attribute 'object_name' := 'FB_init'}
METHOD FB_init : BOOL
VAR_INPUT
	/// if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	/// if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	iIdx: UINT;
	iLength: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
iLength := SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0]);
iIdx := 0;

WHILE (iIdx < iLength) AND (CIf.Job.aCmdList[iIdx].intCmd <> cCMD_INITIALIZED) DO
	iIdx := iIdx + 1; 
END_WHILE

IF (iIdx < iLength) THEN
// Add configuration of own comands	
	CIf.Job.aCmdList[iIdx].intCmd := BASE_PLC.cCMD_RUN;
	CIf.Job.aCmdList[iIdx].strName := 'RUN'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
    iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_Standby;
	CIf.Job.aCmdList[iIdx].strName := 'STANDBY'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_CleanPrintHeads;
	CIf.Job.aCmdList[iIdx].strName := 'CLEANING'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_Calibration;
	CIf.Job.aCmdList[iIdx].strName := 'CALIBRATION'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_ResetAlarm;
	CIf.Job.aCmdList[iIdx].strName := 'RESET ALARM'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := JCL_CmdState.cCMD_RequestState;
	CIf.Job.aCmdList[iIdx].strName := 'REQUEST STATE'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
ELSE
	// Error if the aCmdList Array is to small
END_IF

// set name of class/typ
CIf.Info.strType := 'FB_JCL';
CIf.Info.strFullName := 'Jetter Client';

// set alarm class
SIf.Alm[E_ALM_JCL.JetterNotRun].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterNotRun].strText := 'Jetter is not in RUN';
SIf.Alm[E_ALM_JCL.JetterManualWarning].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[E_ALM_JCL.JetterManualWarning].strText := 'Manual Operation';
SIf.Alm[E_ALM_JCL.JetterManualError].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterManualError].strText := 'Manual Operation';
SIf.Alm[E_ALM_JCL.JetterEOff].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterEOff].strText := 'Jetter in EOFF';
SIf.Alm[E_ALM_JCL.JetterCommunicationLost].eAlmClass := E_AlmClass.OFF;
SIf.Alm[E_ALM_JCL.JetterCommunicationLost].strText := 'Jetter Communication Lost';


// *******************************************************************************
// initial values
// *******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolEnable := TRUE;
CIf.SwCfg.bolSimulation :=  FALSE;

// Fill the lookup table with all valid jetter states
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_EOFFBusy, iAddValue:= 3);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_EOFF, iAddValue:= 4);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_PONBusy, iAddValue:= 1);
fbStateLookup.A_Add(iAddKey := Base_PLC.cSTA_PON, iAddValue:= 2);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_OFFBusy, iAddValue:= 5);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_OFF, iAddValue:= 6);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_ParkBusy, iAddValue:= 211);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_INITBusy, iAddValue:= 7);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_INIT, iAddValue:= 8);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_StandbyBusy, iAddValue:= 201);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_Standby, iAddValue:= 202);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_RUNBusy, iAddValue:= 9);
fbStateLookup.A_Add(iAddKey := BASE_PLC.cSTA_RUN, iAddValue:= 10);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CalibrationBusy, iAddValue:= 203);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_Calibration, iAddValue:= 204);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CleanPrintHeadsBusy, iAddValue:= 205);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_CleanPrintHeads, iAddValue:= 206);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceBusy, iAddValue:= 208);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceInWork, iAddValue:= 209);
fbStateLookup.A_Add(iAddKey := JCL_CmdState.cSTA_MaintenanceDone, iAddValue:= 210);

// prepare to recieve data
m_paNextMsg := ADR(m_naNextMsg);
m_puNextMsg := m_paNextMsg;

SIf.Cur.bolNeedsCleaning:= FALSE;	
SIf.Cur.intJETState:= 0;  // current state not yet known
SIf.Cfg.bolJetterManualModeAllowed := FALSE;

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{d4d47749-8b18-4208-afb7-baf90d92abb7}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUN'}
METHOD PROTECTED sta_RUN : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		IF (SIf.Cfg.bolJetterManualModeAllowed) THEN
			IF SIf.Cur.bolIsLocalControlled THEN
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_MANUALMODE;
			END_IF			
			
			IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		ELSE
			IF (SIf.Cur.intJETState <> cSTA_RUN) THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterNotRun,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
				
			IF SIf.Cur.bolIsLocalControlled THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

		IF (me.StateMachine.intStateNext<>Base_PLC.cSTA_ERROR) AND (me.StateMachine.intStateNext<>JCL_CmdState.cSTA_MANUALMODE)THEN
			CASE me.intCmd OF
				Base_PLC.cCMD_RUN:
					me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;
				JCL_CmdState.cCMD_CleanPrintHeads:
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_CleanPrintHeadsBusy;
				JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
					me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;
			END_CASE
		END_IF
		
	END_IF
	

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_MANUALMODE" Id="{d5482a39-f7d0-450c-9131-bdb36c195d37}">
      <Declaration><![CDATA[METHOD PROTECTED sta_MANUALMODE : BOOL
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle;
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// set Warning
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualWarning,0,ADR(SIf.Alm),E_AlmState.SET,CIf.Job.eMe_ActivAlmClass);
	END_IF


// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		IF SIf.Cfg.bolJetterManualModeAllowed THEN
			IF SIf.Cur.bolIsRemoteControlled THEN
				me.StateMachine.intStateNext := cSTA_OFFBusy;
			END_IF
		ELSE
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualError,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF
		
		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		
		// clear Warning
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterManualWarning,0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
		
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CLEANING" Id="{d8b5640e-bd2c-4070-834f-c22b1a969501}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CLEANING'}
METHOD PROTECTED sta_CLEANING : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

		SIf.Cur.bolNeedsCleaning:= FALSE;			
	END_IF

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		CASE me.intCmd OF	
			Base_PLC.cCMD_RUN:
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;	
			JCL_CmdState.cCMD_Standby, Base_PLC.cCMD_STOP:
				me.StateMachine.intStateNext := JCL_CmdState.cSTA_StandbyBusy;			
		END_CASE

		IF p_fbTCP^.CtrlCIf^.Job.intState <> TCP_CmdState.cSTA_Connect THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_JCL.JetterCommunicationLost,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF

	END_IF

// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAlarms" Id="{da8a737d-f6e9-4e01-8af5-c3968eb71df8}">
      <Declaration><![CDATA[{attribute 'object_name' := 'ResetAlarms'}
METHOD PROTECTED ResetAlarms : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Request jetter state
IF NOT (CIf.SwCfg.bolSimulation) THEN
	stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
	stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
	stNextCommand.usiCommand := JCL_CMD_ResetAlarm;
	pNextCommand := ADR(stNextCommand);	
	p_fbTCP^.M_Push(paPushMsg := pNextCommand);		
END_IF	]]></ST>
      </Implementation>
    </Method>
    <Property Name="CtrlSIf" Id="{dac26a61-5c60-4339-9775-30e5287fd9f3}">
      <Declaration><![CDATA[PROPERTY CtrlSIf : POINTER TO T_Ctrl_SIf_JCL
]]></Declaration>
      <Get Name="Get" Id="{2b10006f-7d50-40f8-96be-a6c71c04098b}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[CtrlSIf := ADR(SIf);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="sta_PON" Id="{f03bc0b2-5ce0-412e-ba2f-2cfed3d8f9fd}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PON'}
METHOD PROTECTED sta_PON : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
// --------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF
	

// --------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN	
		
		IF (SIf.Cur.intJETState = cSTA_EOFF) OR (SIf.Cur.intJETState = cSTA_EOFFBusy) THEN
			me.StateMachine.intStateNext := cSTA_EOFFBusy;
		ELSIF SIf.Cur.bolIsLocalControlled THEN
			me.StateMachine.intStateNext := cSTA_MANUALMODE;
		ELSE
			me.StateMachine.intStateNext := cSTA_OFFBusy;
		END_IF
	
	END_IF


// --------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="cmdCALIBRATION" Id="{f45ad984-9ff6-45af-a792-cf533e90b526}">
      <Declaration><![CDATA[METHOD PROTECTED cmdCALIBRATION : BOOL
VAR
	stNextCommand: T_JCL_Command;
	pNextCommand: POINTER TO T_JCL_Command;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// -----------------------------------------
// Prepare telegram for CALIBRATION
// -----------------------------------------
// Define header
stNextCommand.stHeader.uinMsgId := JCL_MsgId_Command;
stNextCommand.stHeader.udiMsgSize := SIZEOF(T_JCL_Command) - SIZEOF(ST_Header);
// Set jetter CMD
stNextCommand.usiCommand := JCL_CMD_Calibration;
// Push telegram to send buffer
pNextCommand := ADR(stNextCommand);
p_fbTCP^.M_Push(paPushMsg := pNextCommand);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{fddfc156-8f6c-4f79-9567-627b9f9a1187}">
      <Declaration><![CDATA[{attribute 'object_name' := 'Always'}
METHOD PROTECTED Always : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// not inherite from base !!!  special behaviour for this controller
// SUPER^.Always();

// Conditions Always
IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	//me.StateMachine.intStateNext := cSTA_OFFBusy;
	me.bolChangeBackToAUTO := FALSE;
END_IF

IF (CIf.SwCfg.bolExist=FALSE) THEN // hardware of controller does not exist
	me.StateMachine.intStateNext := cSTA_SINGLE_ANSWER;
ELSE
	// Handle command PON
	IF (me.intCmd=cCMD_PON) 
		AND (me.StateMachine.intState<>cSTA_PONBusy) AND (me.StateMachine.intState<>cSTA_PON)
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy) THEN
		me.StateMachine.intStateNext := cSTA_PONBusy;
	ELSIF (me.intCmd=cCMD_OFF) 
		AND (me.StateMachine.intState<>cSTA_PONBusy) AND (me.StateMachine.intState<>cSTA_PON)
		AND (me.StateMachine.intState<>cSTA_OFFBusy) AND (me.StateMachine.intState<>cSTA_OFF)
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)
		AND (me.StateMachine.intState<>JCL_CmdState.cSTA_MANUALMODE) THEN
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF
		
// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// Always handle recieve data from jetter server
	IF NOT CIf.SwCfg.bolSimulation THEN
		THIS^.HandleReceiveData();
	END_IF
	
	// Request state
	// ------------------------------
	IF (me.intCmd=cCMD_RequestState) THEN
		// Request state one time
		CIf.Job.intACmd := Base_PLC.cCMD_DONE;
		CIf.Job.intMCmd := Base_PLC.cCMD_DONE;
		THIS^.RequestState();
	END_IF
	
	// Reset Jetter alarms
	// ------------------------------
	// Can be done over command "cCMD_ResetAlarm" or normal global AlmReset
	IF (me.intCmd=cCMD_ResetAlarm) OR ((CIf.Job.bolAlmReset = TRUE) AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit)) THEN
		CIf.Job.bolAlmReset := FALSE;
		IF (me.intCmd=cCMD_ResetAlarm) THEN
			CIf.Job.intACmd := Base_PLC.cCMD_DONE;
			CIf.Job.intMCmd := Base_PLC.cCMD_DONE;
		END_IF
		// Reset Jetter alarms one time
		THIS^.ResetAlarms();
	END_IF
	
	// EOFF and MANUAL
	IF (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy) AND (me.StateMachine.intState>cSTA_PON)
	  AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit)  THEN
		IF (SIf.Cur.intJETState = cSTA_EOFF) OR (SIf.Cur.intJETState = cSTA_EOFFBusy) THEN
			me.StateMachine.intStateNext := cSTA_EOFFBusy;
		ELSIF (SIf.Cur.bolIsLocalControlled) AND (me.StateMachine.intState<>cSTA_MANUALMODE) AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) THEN
			me.StateMachine.intStateNext := cSTA_MANUALMODE;
		END_IF
	END_IF
		
END_IF]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>