<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.36">
  <POU Name="FB_PBC" Id="{801d871c-05ca-4caf-8aae-4e3b60be1c38}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PBC EXTENDS FB_CtrlBase
VAR_INPUT
	In_bolPaperAvailableExit: BOOL;
	In_bolPaperAvailableEntry: BOOL;
	In_bolCapacityReached: BOOL;
	In_bolDoublePaperDetection: BOOL;
	In_bolTurnTableMiddleSensor: BOOL;
	In_bolAirPressorOk: BOOL;
END_VAR
VAR_OUTPUT
	Out_bolAirOn: BOOL;
END_VAR
VAR
	/// Specific interface struct for public access
	/// -------------------------------------------------------
	SIf					: T_Ctrl_SIf_PBC;
	
	///Sub Controller Pointer
	/// -------------------------------------------------------
	_pDeStacker				: POINTER TO FB_PTB;
	_pDeStackerCIf			: POINTER TO BASE_PLC.T_Ctrl_CIf;
	_pBelt					: POINTER TO FB_PTB;
	_pBeltCIf				: POINTER TO BASE_PLC.T_Ctrl_CIf;
	/// Barcode Reader Variable
	_pBcc					: POINTER TO FB_BCC;
	_pBccCIf				: POINTER TO T_Ctrl_CIf;
	_pBccSIf				: POINTER TO T_Ctrl_SIf_BCC;
	
	/// DataChannel
	_pDataChannel			: POINTER TO FB_DataChannelSenderFifo;
	
	/// Item Tracker
	_pItemTracker			: POINTER TO FB_ITR;
	/// -------------------------------------------------------

	/// Other localy used variables
	/// -------------------------------------------------------
	_uinPaperHight_mm			: UINT := 460;
	_uinPaperWidth_mm			: UINT := 320;
	_intRetry					: INT := 0;
	_udiBufferEmptyTimer_ms		: UDINT;
	_eStopReason				: E_STOPREASON;
	
	_uliLastBarcodeDetected		: ULINT;
	
END_VAR
VAR CONSTANT
	cPAPERPOSITION_TOLERANCE_mm: UINT := 200;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Destacker/Buffer implementation. 


History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		09.07.2013		PC			Start history
0.00.2		05.02.2015		RE			React on StopReleaseItems flag to stop destacking
0.00.3		06.02.2015		RE			Bug fix StopReleaseItems, fixed some comments
___________________________________________________________________________________________________*)


SUPER^();]]></ST>
    </Implementation>
    <Method Name="sta_STANDBYbusy" Id="{02b06a99-f837-4736-a9d5-d5db7f1a752b}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STANDBYbusy : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	IF (CIf.SwCfg.bolSimulation) THEN
		SIf.In.bolCapacityReached.intern := FALSE;
		SIf.In.bolPaperAvailableEntry.intern := TRUE;
		SIf.In.bolPaperAvailableExit.intern := TRUE;
	END_IF

	SIf.Out.bolAirOn.intern := TRUE;
	_eStopReason := E_STOPREASON.None;
	
	_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
	_pBeltCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
	_pBccCIf^.Job.intACmd := cCMD_OFF;
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	IF (_pDeStackerCIf^.Job.intState = cSTA_STOP) AND (_pBeltCIf^.Job.intState = cSTA_RUN) AND (_pBccCIf^.Job.intState = cSTA_OFF) THEN
		CASE me.intCmd OF
			cCMD_STANDBY:
				me.StateMachine.intStateNext := cSTA_STANDBY;
			cCMD_RUN:
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			cCMD_SINGLE:
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			cCMD_STOP:
				me.StateMachine.intStateNext := cSTA_STOPBusy;
		ELSE
			me.StateMachine.intStateNext := cSTA_STANDBY;
		END_CASE
	END_IF
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{055c8361-e13f-49b6-a54f-c37d64c1ecf3}">
      <Declaration><![CDATA[{attribute 'object_name' := 'IoOutBridge'}
METHOD PROTECTED IoOutBridge : BOOL
VAR
	bolSwitchValvesOff: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolAirOn));
	THIS^.Out_bolAirOn := SIf.Out.bolAirOn.map;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{064f6f56-1229-4d9e-93fb-d02fd960c39b}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCtrlSIf'}
METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_PBC
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{258b3a1f-3443-4b8b-8ba1-d0c9e4ba4a4e}">
      <Declaration><![CDATA[{attribute 'object_name' := 'StateMachine'}
METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	BASE_PLC.cSTA_STANDBY:
		THIS^.sta_STANDBY();
	BASE_PLC.cSTA_STANDBYBusy:
		THIS^.sta_STANDBYbusy();
	BASE_PLC.cSTA_RUN:
		THIS^.sta_RUN();
	BASE_PLC.cSTA_RUNBusy:
		THIS^.sta_RUNbusy();
    BASE_PLC.cSTA_STOPBusy: 
        THIS^.sta_STOPbusy();
    BASE_PLC.cSTA_STOP: 
        THIS^.sta_STOP();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{259bd6c7-9989-49d3-8b44-27554720c2fa}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CtrlInit'}
METHOD CtrlInit : BOOL
VAR
	pBccSIf: POINTER TO T_Ctrl_SIf_BCC;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

_pDeStackerCIf 	:= AddChild(_pDeStacker^);
_pBeltCIf 		:= AddChild(_pBelt^);
_pBccCIf		:= AddChild(_pBcc^);
_pBccSIf		:= _pBcc^.CtrlSIf;




]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOP" Id="{27ee82db-56fb-4a1c-bc6e-c4e69a8329f6}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_STOP'}
METHOD PROTECTED sta_STOP : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	IF CIf.SwCfg.bolSimulation THEN
		SIf.In.bolPaperAvailableEntry.intern := TRUE;
		SIf.In.bolDoublePaperDetection.intern := FALSE;	
		SIf.In.bolPaperAvailableExit.intern := FALSE;	
		SIf.In.bolCapacityReached.intern := TRUE;
	END_IF
	
	me.SubStateMachine.intState 	:= PBC_CmdState.cSUB_POSITIONSTARTbusy;
	me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	sub_TransportPaperToFront(me.SubStateMachine.intState,SIf,me.StateMachine.intStateNext, me.SubStateMachine.intStateNext);
	
	CASE me.SubStateMachine.intState OF
		PBC_CmdState.cSUB_WAITPAPER,
		PBC_CmdState.cSUB_READYEJECT:
			CASE me.intCmd OF
				BASE_PLC.cCMD_RUN:
					me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
				BASE_PLC.cCMD_STANDBY:
					me.StateMachine.intStateNext := BASE_PLC.cSTA_STANDBYBusy;
			END_CASE
	END_CASE
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	me.SubStateMachine.intState 	:= BASE_PLC.cSTA_INITIALIZED;
	me.SubStateMachine.intStateNext := BASE_PLC.cSTA_INITIALIZED;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{3457f496-ee56-40af-94c5-0440a0384819}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERROR'}
METHOD PROTECTED sta_ERROR : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		_pDeStackerCIf^.Job.intACmd 	:= BASE_PLC.cCMD_STOP;
		//pBeltCIf^.Job.intACmd 		:= BASE_PLC.cCMD_STOP;
		
		// clear alarm
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.DoNotReleaseItems),0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="PaperWidth" Id="{46ee2dcb-a500-485e-931d-c416c8a8fa97}">
      <Declaration><![CDATA[PROPERTY PaperWidth : UINT
]]></Declaration>
      <Set Name="Set" Id="{5a76fba3-68d6-421d-ab71-e070d5276804}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[_uinPaperWidth_mm := PaperWidth;]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{5dd74c37-7a79-4105-88ce-6c2f46bdeee6}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[PaperWidth := _uinPaperWidth_mm;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="sta_STOPbusy" Id="{5482cca9-1d01-48ad-bede-3f0b525b2122}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_STOPbusy'}
METHOD PROTECTED sta_STOPbusy : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
	
	// set alarm
	IF (NOT SIf.Par.bolAutomaticMode) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.DoNotReleaseItems),0,ADR(SIf.Alm),E_AlmState.SET,CIf.Job.eMe_ActivAlmClass);
	END_IF
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateNext := BASE_PLC.cSTA_STOP;
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="BarcodeReader" Id="{5f1ee132-0ad5-49c0-9617-29071423cb9e}">
      <Declaration><![CDATA[PROPERTY BarcodeReader : POINTER TO FB_BCC
]]></Declaration>
      <Set Name="Set" Id="{3b67f93a-6383-46a3-adf9-8a4567531619}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[_pBcc := BarcodeReader;]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{7e5e83de-a338-44db-8b8b-09ca813d32ab}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[BarcodeReader := _pBcc;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="IoInBridge" Id="{6216192c-85f9-4cff-931f-7f15fa051d44}">
      <Declaration><![CDATA[{attribute 'object_name' := 'IoInBridge'}
METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
SIf.In.bolCapacityReached.map			:= THIS^.In_bolCapacityReached				;
SIf.In.bolPaperAvailableEntry.map		:= THIS^.In_bolPaperAvailableEntry	;
SIf.In.bolPaperAvailableExit.map		:= THIS^.In_bolPaperAvailableExit		;
SIf.In.bolDoublePaperDetection.map		:= NOT THIS^.In_bolDoublePaperDetection		;
SIf.In.bolTurnTableMiddleSensor.map		:= NOT THIS^.In_bolTurnTableMiddleSensor		;
SIf.In.bolAirPressorOk.map				:= THIS^.In_bolAirPressorOk		;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolCapacityReached));
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolPaperAvailableEntry));
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolPaperAvailableExit));
	BASE_PLC.getInBolDebounced(CIf.Job.bolIoForce,me.FUBInfo.udiSample_ms, SIf.Par.udiDoublePaperDebounceTime_ms, ADR(SIf.In.bolDoublePaperDetection));
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolTurnTableMiddleSensor));
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolAirPressorOk));
ELSE
	SIf.In.bolDoublePaperDetection.intern := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="Belt" Id="{6a9a6515-c0c3-4aa7-8b2f-1d3cc382015a}">
      <Declaration><![CDATA[PROPERTY Belt : POINTER TO FB_PTB
]]></Declaration>
      <Get Name="Get" Id="{13dfcb7b-e335-449c-8d6d-c61803d7dbcc}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Belt := _pBelt;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{6f4ff6c3-bd50-4246-ba92-d9ca325818f4}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[_pBelt := Belt;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="sta_ERRORQuit" Id="{86e035f1-200b-405a-a565-7751ebd68fb6}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERRORQuit'}
METHOD PROTECTED sta_ERRORQuit : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		// evtl. wait time if reset of device is necessary and then decide to go to states or ERROR state
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
			CIf.Job.bolAlmReset := FALSE;
		END_IF
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = FALSE) THEN
			IF (me.StateMachine.intStateHistory<=BASE_PLC.cSTA_PON) THEN
				me.StateMachine.intStateNext := BASE_PLC.cSTA_PONBusy;
			END_IF;

			CASE me.intCmd OF
				BASE_PLC.cCMD_OFF:
					me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
				cCMD_STOP, Base_PLC.cCMD_STANDBY:
					me.StateMachine.intStateNext := Base_PLC.cSTA_STANDBYBusy;
				PBC_CmdState.cCMD_SINGLE,
				BASE_PLC.cCMD_RUN:
					me.StateMachine.intStateNext := cSTA_STANDBYbusy;
			ELSE
				CASE me.StateMachine.intStateHistory OF
					cSTA_STOP:
						me.StateMachine.intStateNext := cSTA_STOPBusy;
					BASE_PLC.cSTA_RUN:
						me.StateMachine.intStateNext := cSTA_STANDBYbusy;
				ELSE
					me.StateMachine.intStateNext := cSTA_OFFBusy;
				END_CASE
			END_CASE
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="DataChannel" Id="{8deb4305-f748-4bc7-a211-23c40b557884}">
      <Declaration><![CDATA[PROPERTY DataChannel : POINTER TO FB_DataChannelSenderFifo
]]></Declaration>
      <Set Name="Set" Id="{acd90fda-fde6-4c98-ad7c-489043a4a6ec}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[_pDataChannel := DataChannel;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="CtrlSIf" Id="{8f6f3f4c-fb1e-44df-9cc9-6f3a79f322a0}">
      <Declaration><![CDATA[PROPERTY CtrlSIf : POINTER TO T_Ctrl_SIf_PBC
]]></Declaration>
      <Get Name="Get" Id="{98a09405-42be-4cfe-8cf8-65093f849be1}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[CtrlSIf := ADR(SIf);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Always" Id="{9b23a10f-b743-4067-9768-47b400455c69}">
      <Declaration><![CDATA[{attribute 'object_name' := 'Always'}
METHOD PROTECTED Always : BOOL
VAR
	pItem: POINTER TO T_IdBase_DCH;
	bResult: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	// check if DeStacker is empty
	IF NOT SIf.In.bolPaperAvailableEntry.intern AND NOT SIf.In.bolPaperAvailableExit.intern THEN
		_udiBufferEmptyTimer_ms := _udiBufferEmptyTimer_ms + me.FUBInfo.udiSample_ms;
		IF _udiBufferEmptyTimer_ms > 3000 THEN
			SIf.Cur.intPaperInBufferCount := 0;
		END_IF
	ELSE
		_udiBufferEmptyTimer_ms := 0;
		SIf.Cur.intPaperInBufferCount := -1;
	END_IF

END_IF

// ----------------------------------------------------------------------------------
// Conditions Always
IF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.Alarm.eActivAlmClass=E_AlmClass.OFF) OR (me.intCmd=cCMD_OFF) OR (me.intCmd=BASE_PLC.cCMD_EOFF))
		 AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) AND
		(me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)) THEN
	// alarm evt EOFF, OFF or cmd off
	me.StateMachine.intStateNext := cSTA_OFFBusy;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBY" Id="{a24234ab-417d-4fe9-a347-87605f2302cd}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STANDBY : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	me.SubStateMachine.intState 	:= PBC_CmdState.cSUB_POSITIONSTARTbusy;
	me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;

	IF CIf.SwCfg.bolSimulation THEN
		SIf.In.bolPaperAvailableEntry.intern := TRUE;
		SIf.In.bolDoublePaperDetection.intern := FALSE;	
		SIf.In.bolPaperAvailableExit.intern := TRUE;	
		SIf.In.bolCapacityReached.intern := TRUE;
		
		IF _pItemTracker <> NULL THEN
			IF _pItemTracker^.Enabled THEN
				IF _pItemTracker^.Enabled AND _pItemTracker^.Count = 0 THEN
					SIf.In.bolPaperAvailableEntry.intern := FALSE;
					SIf.In.bolPaperAvailableExit.intern := FALSE;	
					SIf.In.bolCapacityReached.intern := FALSE;
					me.SubStateMachine.intState 	:= PBC_CmdState.cSUB_WAITPAPER;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
				END_IF			
			END_IF
		END_IF
	END_IF
END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	sub_TransportPaperToFront(me.SubStateMachine.intState,SIf,me.StateMachine.intStateNext, me.SubStateMachine.intStateNext);
	
	CASE me.SubStateMachine.intState OF
		PBC_CmdState.cSUB_WAITPAPER,
		PBC_CmdState.cSUB_READYEJECT:
			CASE me.intCmd OF
				BASE_PLC.cCMD_RUN,
				PBC_CmdState.cCMD_SINGLE:
					me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
			END_CASE
	END_CASE
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	me.SubStateMachine.intState 	:= BASE_PLC.cSTA_INITIALIZED;
	me.SubStateMachine.intStateNext := BASE_PLC.cSTA_INITIALIZED;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{ac6ed3e2-3052-478c-84c6-bce3f9822735}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUN'}
METHOD PROTECTED sta_RUN : BOOL
VAR
	pItem					: POINTER TO T_IdBase_DCH;
	bolRelease				: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	
	IF (me.intCmd = BASE_PLC.cCMD_RUN) OR (me.intCmd = PBC_CmdState.cCMD_SINGLE) THEN
		CIf.Job.intACmd := BASE_PLC.cCMD_DONE;
		CIf.Job.intMCmd := BASE_PLC.cCMD_DONE;
	END_IF
	
	SIf.Cur.uinSheetToSheetTime := 0;
	_intRetry := 0;
	
	me.SubStateMachine.intState 	:= PBC_CmdState.cSUB_POSITIONSTARTbusy;
	me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;

	IF CIf.SwCfg.bolSimulation THEN
		SIf.In.bolPaperAvailableEntry.intern := TRUE;
		SIf.In.bolDoublePaperDetection.intern := FALSE;	
		SIf.In.bolPaperAvailableExit.intern := TRUE;	
		SIf.In.bolCapacityReached.intern := TRUE;
		
		IF _pItemTracker <> NULL THEN
			IF _pItemTracker^.Enabled THEN
				IF _pItemTracker^.Enabled AND _pItemTracker^.Count = 0 THEN
					SIf.In.bolPaperAvailableEntry.intern := FALSE;
					SIf.In.bolPaperAvailableExit.intern := FALSE;	
					SIf.In.bolCapacityReached.intern := FALSE;
					me.SubStateMachine.intState 	:= PBC_CmdState.cSUB_WAITPAPER;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
				END_IF			
			END_IF
		END_IF
	END_IF
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	IF (SIf.In.bolDoublePaperDetection.intern) THEN
		IF SIf.Par.bolEnableDoublePaperDetection THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.DoublePaperError),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		ELSE
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.DoublePaperWarning),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		END_IF
	ELSE	
		CASE me.SubStateMachine.intState OF
			// substate Wait paper - wait for the next paper if the buffer was empty
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_WAITPAPER:
				IF CIf.SwCfg.bolSimulation THEN
					SIf.In.bolPaperAvailableEntry.intern := TRUE;
					SIf.In.bolPaperAvailableExit.intern := FALSE;	
					SIf.In.bolCapacityReached.intern := TRUE;
					
					IF _pItemTracker <> NULL THEN
						IF _pItemTracker^.Enabled THEN
							SIf.In.bolPaperAvailableEntry.intern := FALSE;
							SIf.In.bolCapacityReached.intern := FALSE;

							IF _pItemTracker^.Enabled AND _pItemTracker^.Count > 0 THEN
								SIf.In.bolPaperAvailableEntry.intern := TRUE;
								SIf.In.bolCapacityReached.intern := TRUE;
							END_IF			
						END_IF
					END_IF
				END_IF

				IF NOT SIf.In.bolPaperAvailableExit.intern THEN
					IF SIf.In.bolCapacityReached.intern OR SIf.In.bolPaperAvailableEntry.intern THEN
						me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
					END_IF
				ELSE
					me.SubStateMachine.intStateNext := cSUB_EVALUATEEJECT;
				END_IF
				
			// substate PositionStart busy
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_POSITIONSTARTbusy:
				IF CIf.SwCfg.bolSimulation THEN
					SIf.In.bolPaperAvailableEntry.intern := TRUE;
					SIf.In.bolCapacityReached.intern := TRUE;
					
					IF _pItemTracker <> NULL THEN
						IF _pItemTracker^.Enabled THEN
							SIf.In.bolPaperAvailableEntry.intern := FALSE;
							SIf.In.bolCapacityReached.intern := FALSE;

							IF _pItemTracker^.Enabled AND _pItemTracker^.Count > 0 THEN
								SIf.In.bolPaperAvailableEntry.intern := TRUE;
								SIf.In.bolCapacityReached.intern := TRUE;
							END_IF			
						END_IF
					END_IF
				END_IF

				IF NOT SIf.In.bolPaperAvailableExit.intern THEN
					SIf.Cur.bolPaperBeforeEjectAvailable := SIf.In.bolCapacityReached.intern OR SIf.In.bolPaperAvailableEntry.intern;
					_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONbusy;
				ELSE
					me.SubStateMachine.intStateNext := cSUB_EVALUATEEJECT;
				END_IF
	
			// substate Position busy
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_POSITIONbusy:
				IF me.SubStateMachine.udiTimeInState_ms <= SIf.Par.udiPaperTransportTime THEN
					IF SIf.In.bolPaperAvailableExit.intern THEN
						_intRetry := 0;
						_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
						_pBccCIf^.Job.intACmd := BCC_CmdState.cBCC_CMD_READ;
						me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTOPbusy;
					END_IF
				ELSE
					IF SIf.Cur.bolPaperBeforeEjectAvailable OR SIf.In.bolCapacityReached.intern OR SIf.In.bolPaperAvailableEntry.intern THEN
						IF DINT_TO_UDINT(_intRetry) < SIf.Par.udiPaperInjectRetries THEN
							_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
							_intRetry := _intRetry + 1;
							pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperInjectRetry),_intRetry,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
							me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONRETRYSTOP;	
						ELSE
							_intRetry := 0;
							pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperInject),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
							me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;	
						END_IF
					ELSE
						_intRetry := 0;
						_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
						me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTOPbusy;
					END_IF 
				END_IF

				// Simulation
				IF CIf.SwCfg.bolSimulation THEN
					IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiSimPaperTransportTime) AND NOT SIf.In.bolPaperAvailableExit.intern THEN
						SIf.In.bolPaperAvailableExit.intern := TRUE;	
					END_IF
				END_IF
				// -----------------------------------
	
			// Wait that the moto stops
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_POSITIONRETRYSTOP:
				IF _pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP THEN
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONRETRYDELAY;
				END_IF

			// Stop the motor and way for x ms
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_POSITIONRETRYDELAY:
				IF me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiPaperInjectRetryPauseTime_ms THEN
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
				END_IF

			// substate PositionStop busy
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_POSITIONSTOPbusy:
				IF (_pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP) 
					AND ((_pBccCIf^.Job.intState = BCC_CmdState.cBCC_STA_READ) OR  NOT SIf.In.bolPaperAvailableExit.intern) THEN
					
					IF NOT CIf.SwCfg.bolSimulation THEN
						_uliLastBarcodeDetected := _pBccSIf^.Cur.stData.uliBarCode;
					ELSE
						IF _pItemTracker <> NULL THEN
							_uliLastBarcodeDetected := _pItemTracker^.Peek();
						ELSE
							_uliLastBarcodeDetected := _pBccSIf^.Cur.stData.uliBarCode;
						END_IF
					END_IF

					_pBccCIf^.Job.intACmd := cCMD_OFF;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EVALUATEEJECT;
				END_IF

			// substate Evaluate Eject
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_EVALUATEEJECT:
				// Eject next paper if there are still paper to edject or endless ejection
				IF (((SIf.Cur.uinPaperToEjectCount > 0) AND NOT SIf.Par.bolAutomaticMode AND NOT StopReleaseItems()) 
					OR (SIf.Par.bolAutomaticMode AND NOT StopReleaseItems())) THEN 
					// Make a delay from sheet to sheet if it is not the first sheet
					IF SIf.In.bolPaperAvailableExit.intern THEN
						IF SIf.Par.bolAutomaticMode THEN
							bolRelease := TRUE;
							
							IF _pItemTracker <> NULL THEN
								bolRelease := _pItemTracker^.Release(_uliLastBarcodeDetected);
							END_IF
							
							IF  (SIf.Cur.uinSheetToSheetTime > SIf.Par.udiSheetToSheetTime) AND bolRelease THEN
								SIf.Cur.uinSheetToSheetTime := 0;
								me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EJECTSTARTbusy;
							END_IF
						ELSE
							IF (SIf.Cur.uinSheetToSheetTime > SIf.Par.udiManualSheetToSheetTime_ms) OR (SIf.Cur.uinPaperToEjectCount = SIf.Cur.uinPaperToEjectParameter) THEN
								SIf.Cur.uinSheetToSheetTime := 0;
								me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EJECTSTARTbusy;
							END_IF	
						END_IF

					ELSE
						me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
					END_IF
				ELSE
					IF StopReleaseItems() THEN
						me.SubStateMachine.intStateNext := cSUB_EJECTPAUSE;
					ELSE
						me.StateMachine.intStateNext := cSTA_STANDBYBusy;
					END_IF
				END_IF
	
			// substate Pause Eject
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_EJECTPAUSE:
				IF SIf.In.bolPaperAvailableExit.intern THEN
					IF NOT StopReleaseItems() THEN
						me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EVALUATEEJECT;
					END_IF
				ELSE
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
				END_IF
			
			

			// substate EjectStart busy
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_EJECTSTARTbusy:
				_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
				SIf.Cur.uinPaperToPaperTime_ms := UDINT_TO_UINT((_uinPaperHight_mm + 100) * 1000 / _pDeStacker^.CtrlSIf^.Par.rBeltParam.uinBeltSpeed);
				SIf.Par.udiSimPaperToPaperTransportTime := SIf.Cur.uinPaperToPaperTime_ms / 3; 

				// Send the Barcode to Saber
				IF (_pDataChannel <> NULL) AND (SIf.Cfg.bolEnableDataChannel) THEN
					IF UINT_TO_INT(_pDataChannel^.ItemCount) >= _pDataChannel^.MaxFifoSize THEN
						pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_BCH.DataChannelBufferFull,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					ELSE
						pItem := __NEW(T_IdBase_DCH);
						pItem^.rBaseInfo.eHealth := E_ItemHealth.Healthy;
						pItem^.rBaseInfo.uinModuleId := 1;
						pItem^.rBaseInfo.uinActualPosition := 1;
						pItem^.udiIdentification := _uliLastBarcodeDetected;
						_pDataChannel^.Push(pItem);					
					END_IF
				END_IF
				
				IF _pItemTracker <> NULL THEN
					_pItemTracker^.RemoveBarcode(_uliLastBarcodeDetected);
				END_IF
				
				_uliLastBarcodeDetected := 0;

				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EJECTbusy;
				// Add here the message to Saber about the barcode.
	
			// substate Eject busy
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_EJECTbusy:
				IF NOT SIf.In.bolPaperAvailableExit.intern AND NOT SIf.Cfg.bolUseTurnTableSensorForEject THEN
					_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EJECTSTOPbusy;
				END_IF
	
				IF SIf.In.bolTurnTableMiddleSensor.intern AND SIf.Cfg.bolUseTurnTableSensorForEject THEN
					_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPERGONETABLE;
				END_IF
				
				IF (me.SubStateMachine.udiTimeInState_ms > SIf.Cur.uinPaperToPaperTime_ms) THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperTransport),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;	
				END_IF

				// Simulation
				IF CIf.SwCfg.bolSimulation THEN
					IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiSimPaperToPaperTransportTime) THEN
						IF SIf.Cfg.bolUseTurnTableSensorForEject THEN
							SIf.In.bolTurnTableMiddleSensor.intern := TRUE;
						ELSE
							SIf.In.bolPaperAvailableExit.intern := FALSE;	
						END_IF	
					END_IF
				END_IF
				// -----------------------------------
	
			// substate Wait Paper Gone Table - Wait until the paper is gone from the turn table
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_WAITPAPERGONETABLE:
				IF NOT SIf.In.bolTurnTableMiddleSensor.intern THEN
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EJECTSTOPbusy;
				END_IF

				// Simulation
				IF CIf.SwCfg.bolSimulation THEN
					IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiSimPaperToPaperTransportTime) THEN
						SIf.In.bolTurnTableMiddleSensor.intern := FALSE;
					END_IF
				END_IF
				// -----------------------------------

	
			// substate EjectStop busy
			// ------------------------------------------------------------------------
			PBC_CmdState.cSUB_EJECTSTOPbusy:
				IF _pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP THEN
					IF SIf.Cur.uinPaperToEjectCount > 0 THEN
						SIf.Cur.uinPaperToEjectCount := SIf.Cur.uinPaperToEjectCount - 1;
					END_IF
					
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;

					IF CIf.SwCfg.bolSimulation THEN
						SIf.In.bolPaperAvailableExit.intern := FALSE;
						
						IF _pItemTracker <> NULL THEN
							IF _pItemTracker^.Enabled THEN
								IF _pItemTracker^.Enabled AND _pItemTracker^.Count = 0 THEN
									me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
								END_IF			
							END_IF
						END_IF
					END_IF
				END_IF
		END_CASE
	END_IF
	
	CASE me.SubStateMachine.intState OF
		PBC_CmdState.cSUB_WAITPAPER,
		PBC_CmdState.cSUB_EJECTPAUSE,
		PBC_CmdState.cSUB_EVALUATEEJECT:
			CASE me.intCmd OF
				cCMD_STOP:
					me.StateMachine.intStateNext := BASE_PLC.cSTA_STOPBusy;
				cCMD_STANDBY:
					me.StateMachine.intStateNext := BASE_PLC.cSTA_STANDBYBusy;
			END_CASE
	END_CASE
	
	SIf.Cur.uinSheetToSheetTime := UDINT_TO_UINT(SIf.Cur.uinSheetToSheetTime + me.FUBInfo.udiSample_ms);
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	me.SubStateMachine.intState 	:= BASE_PLC.cSTA_INITIALIZED;
	me.SubStateMachine.intStateNext := BASE_PLC.cSTA_INITIALIZED;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StopReleaseItems" Id="{bd9706bf-3f3b-4360-a5fc-30313018d794}">
      <Declaration><![CDATA[METHOD PROTECTED StopReleaseItems : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[StopReleaseItems := SIf.Par.bolStopReleaseItems AND SIf.Cfg.bolEnableSaberStopDeStack;]]></ST>
      </Implementation>
    </Method>
    <Property Name="PaperHight" Id="{c5506708-4c61-4b80-9476-2d443bae7ab5}">
      <Declaration><![CDATA[PROPERTY PaperHight : UINT
]]></Declaration>
      <Set Name="Set" Id="{8732534e-cdd5-4c53-ae64-6373ae43e29e}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[_uinPaperHight_mm := PaperHight;]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{e8fccd87-a8be-4928-81ce-c2aeb33d1f11}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[PaperHight := _uinPaperHight_mm;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="sta_OFF" Id="{c779f42c-3c1a-4201-b388-776d0c185716}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFF'}
METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		CASE me.intCmd OF
			cCMD_RUN, PBC_CmdState.cCMD_SINGLE, cCMD_STANDBY : 
				me.StateMachine.intStateNext := cSTA_STANDBYBusy;
		END_CASE
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{c88c4301-1386-498b-87d0-82b5dd6ccdff}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFFBusy'}
METHOD PROTECTED sta_OFFBusy : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		SIf.Out.bolAirOn.intern := FALSE;
		
		_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_OFF;
		_pBeltCIf^.Job.intACmd := BASE_PLC.cCMD_OFF;
		_pBccCIf^.Job.intACmd := cCMD_OFF;

		// clear alarm
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.DoNotReleaseItems),0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		IF (_pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_OFF)
		  AND (_pBeltCIf^.Job.intState = BASE_PLC.cSTA_OFF)
		  AND (_pBccCIf^.Job.intState = cSTA_OFF) 
		  AND (NOT SIf.In.bolAirPressorOk.intern OR (NOT SIf.Cfg.bolGranulatAirPressureUnitAvailable))  THEN
			me.StateMachine.intStateNext := BASE_PLC.cSTA_OFF;
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{cca628d8-4605-41b5-8bb2-fe209143e8ab}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PON'}
METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		;
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{cf61f6bf-8b17-4dfd-a89c-3655e9bfe9d6}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCmdState'}
METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states

IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		CASE intCmdState OF
			PBC_CmdState.cCMD_SINGLE: 
				getCmdState := 'SINGLE';
		END_CASE;
	ELSE
		// States's
		CASE intCmdState OF
			PBC_CmdState.cSUB_WAITPAPER: 
				getCmdState := 'WAITPAPER';
			PBC_CmdState.cSUB_EJECTSTARTbusy: 
				getCmdState := 'EJECTSTARTbusy';
			PBC_CmdState.cSUB_EJECTbusy: 
				getCmdState := 'EJECTbusy';

			PBC_CmdState.cSUB_EJECTSTOPbusy: 
				getCmdState := 'EJECTSTOPbusy';
			PBC_CmdState.cSUB_EVALUATEEJECT: 
				getCmdState := 'EVALUATEEJECT';
			PBC_CmdState.cSUB_POSITIONbusy: 
				getCmdState := 'POSITIONbusy';

			PBC_CmdState.cSUB_POSITIONSTARTbusy: 
				getCmdState := 'POSITIONSTARTbusy';
			PBC_CmdState.cSUB_POSITIONSTOPbusy: 
				getCmdState := 'POSITIONSTOPbusy';
			PBC_CmdState.cSUB_READYEJECT: 
				getCmdState := 'READYEJECT';
			PBC_CmdState.cSUB_WAITPAPERGONETABLE: 
				getCmdState := 'WAITPAPERGONETABLE';
			PBC_CmdState.cSUB_POSITIONRETRYDELAY: 
				getCmdState := 'POSITIONRETRYDELAY';
			PBC_CmdState.cSUB_POSITIONRETRYSTOP: 
				getCmdState := 'POSITIONRETRYSTOP';
			PBC_CmdState.cSUB_EJECTPAUSE: 
				getCmdState := 'PAUSE';
		END_CASE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="DeStacker" Id="{d69653a0-ea1a-4880-ad63-23d8553039b3}">
      <Declaration><![CDATA[PROPERTY DeStacker : POINTER TO FB_PTB
]]></Declaration>
      <Set Name="Set" Id="{03b2a246-69e5-4565-816d-d9ba2c26d65b}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[_pDeStacker := DeStacker;]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{732c5506-f935-446f-a81d-ee3f5176bad9}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[DeStacker := _pDeStacker;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="CountPaper" Id="{dc226d1c-e4d2-4781-be06-f07b163832fa}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CountPaper'}
METHOD PROTECTED CountPaper : UINT
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Property Name="ItemTracker" Id="{df160a85-71f0-435d-b353-263f468574ea}">
      <Declaration><![CDATA[PROPERTY PUBLIC ItemTracker : POINTER TO FB_ITR]]></Declaration>
      <Set Name="Set" Id="{8c268050-39ca-4a10-90cf-d04727d37fe9}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_pItemTracker := ItemTracker;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="sub_TransportPaperToFront" Id="{e94f09fd-1d5d-43d6-93d3-20b84d2ff719}">
      <Declaration><![CDATA[METHOD PROTECTED sub_TransportPaperToFront : INT
VAR_INPUT
	intSubState				: INT;
END_VAR
VAR_IN_OUT
	SIf						: T_Ctrl_SIf_PBC;
	intStateNext			: INT;
	intSubStateNext			: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE intSubState OF
	// substate Wait paper - wait for the next paper if the buffer was empty
	// ------------------------------------------------------------------------
	PBC_CmdState.cSUB_WAITPAPER:
		IF CIf.SwCfg.bolSimulation THEN
			SIf.In.bolPaperAvailableEntry.intern := TRUE;
			SIf.In.bolPaperAvailableExit.intern := FALSE;	
			SIf.In.bolCapacityReached.intern := TRUE;
			
			IF _pItemTracker <> NULL THEN
				IF _pItemTracker^.Enabled THEN
					SIf.In.bolPaperAvailableEntry.intern := FALSE;
					SIf.In.bolCapacityReached.intern := FALSE;

					IF _pItemTracker^.Enabled AND _pItemTracker^.Count > 0 THEN
						SIf.In.bolPaperAvailableEntry.intern := TRUE;
						SIf.In.bolCapacityReached.intern := TRUE;
					END_IF			
				END_IF
			END_IF
		END_IF

		IF NOT SIf.In.bolPaperAvailableExit.intern THEN
			IF SIf.In.bolCapacityReached.intern OR SIf.In.bolPaperAvailableEntry.intern THEN
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
			END_IF
		ELSE
			me.SubStateMachine.intStateNext := cSUB_READYEJECT;
		END_IF
		
	// substate Wait paper - wait for the next paper if the buffer was empty
	// ------------------------------------------------------------------------
	PBC_CmdState.cSUB_POSITIONSTARTbusy:
		IF CIf.SwCfg.bolSimulation THEN
			SIf.In.bolPaperAvailableEntry.intern := TRUE;
			SIf.In.bolCapacityReached.intern := TRUE;
			
			IF _pItemTracker <> NULL THEN
				IF _pItemTracker^.Enabled THEN
					SIf.In.bolPaperAvailableEntry.intern := FALSE;
					SIf.In.bolCapacityReached.intern := FALSE;

					IF _pItemTracker^.Enabled AND _pItemTracker^.Count > 0 THEN
						SIf.In.bolPaperAvailableEntry.intern := TRUE;
						SIf.In.bolCapacityReached.intern := TRUE;
					END_IF			
				END_IF
			END_IF
		END_IF

		IF NOT SIf.In.bolPaperAvailableExit.intern THEN
			SIf.Cur.bolPaperBeforeEjectAvailable := SIf.In.bolCapacityReached.intern OR SIf.In.bolPaperAvailableEntry.intern;
			_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
			me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONbusy;
		ELSE
			me.SubStateMachine.intStateNext := cSUB_READYEJECT;
		END_IF

	// substate Wait paper - wait for the next paper if the buffer was empty
	// ------------------------------------------------------------------------
	PBC_CmdState.cSUB_POSITIONbusy:
		IF me.SubStateMachine.udiTimeInState_ms <= SIf.Par.udiPaperTransportTime THEN
			IF SIf.In.bolPaperAvailableExit.intern THEN
				_intRetry := 0;
				_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
				_pBccCIf^.Job.intACmd := BCC_CmdState.cBCC_CMD_READ;
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTOPbusy;
			END_IF
		ELSE
			IF SIf.Cur.bolPaperBeforeEjectAvailable OR SIf.In.bolCapacityReached.intern OR SIf.In.bolPaperAvailableEntry.intern THEN
				IF DINT_TO_UDINT(_intRetry) < SIf.Par.udiPaperInjectRetries THEN
					_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
					_intRetry := _intRetry + 1;
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperInjectRetry),_intRetry,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONRETRYSTOP;	
				ELSE
					_intRetry := 0;
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperInject),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;	
				END_IF
			ELSE
				_intRetry := 0;
				_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTOPbusy;
			END_IF 
		END_IF

		// Simulation
		IF CIf.SwCfg.bolSimulation THEN
			IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiSimPaperTransportTime) AND NOT SIf.In.bolPaperAvailableExit.intern THEN
				SIf.In.bolPaperAvailableExit.intern := TRUE;	
			END_IF
		END_IF
		// -----------------------------------

	// substate Wait paper - wait for the next paper if the buffer was empty
	// ------------------------------------------------------------------------
	PBC_CmdState.cSUB_POSITIONSTOPbusy:
		IF (_pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP) 
			AND ((_pBccCIf^.Job.intState = BCC_CmdState.cBCC_STA_READ) OR  NOT SIf.In.bolPaperAvailableExit.intern) THEN

			IF NOT CIf.SwCfg.bolSimulation THEN
				_uliLastBarcodeDetected := _pBccSIf^.Cur.stData.uliBarCode;
			ELSE
				IF _pItemTracker <> NULL THEN
					_uliLastBarcodeDetected := _pItemTracker^.Peek();
				ELSE
					_uliLastBarcodeDetected := _pBccSIf^.Cur.stData.uliBarCode;
				END_IF
			END_IF

			_pBccCIf^.Job.intACmd := cCMD_OFF;

			IF SIf.In.bolPaperAvailableExit.intern THEN
				intSubStateNext := PBC_CmdState.cSUB_READYEJECT;
			ELSE
				intSubStateNext := PBC_CmdState.cSUB_WAITPAPER;
			END_IF
		END_IF

	PBC_CmdState.cSUB_READYEJECT:
		IF NOT SIf.In.bolPaperAvailableExit.intern THEN
			intSubStateNext := PBC_CmdState.cSUB_WAITPAPER;
		END_IF
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{ea82e82e-b90d-44dd-bbc2-dc8fc171b5c5}">
      <Declaration><![CDATA[{attribute 'object_name' := 'FB_init'}
METHOD FB_init : BOOL
VAR_INPUT
	/// if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	/// if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	iIdx: UINT;
	iLength: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
iLength := SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0]);
iIdx := 0;

WHILE (iIdx < iLength) AND (CIf.Job.aCmdList[iIdx].intCmd <> cCMD_INITIALIZED) DO
	iIdx := iIdx + 1; 
END_WHILE

IF (iIdx < iLength) THEN
// Add configuration of own comands	
	CIf.Job.aCmdList[iIdx].intCmd := BASE_PLC.cCMD_RUN;
	CIf.Job.aCmdList[iIdx].strName := 'RUN'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := BASE_PLC.cCMD_STOP;
	CIf.Job.aCmdList[iIdx].strName := 'STOP'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := PBC_CmdState.cCMD_SINGLE;
	CIf.Job.aCmdList[iIdx].strName := 'SINGLE'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
ELSE
	// Error if the aCmdList Array is to small
END_IF

// set name of class/typ
CIf.Info.strType := 'FB_PBC';  
CIf.Info.strFullName := 'Paper Buffer Controller';

// set alarm class
SIf.Alm[E_ALM_PBC.BufferEmpty].eAlmClass := Base_PLC.E_AlmClass.WARNING;
SIf.Alm[E_ALM_PBC.BufferEmpty].strText := 'Buffer is Empty'; 
SIf.Alm[E_ALM_PBC.BufferFull].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_PBC.BufferFull].strText := 'Buffer reached capacity limit';
SIf.Alm[E_ALM_PBC.PaperTransport].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_PBC.PaperTransport].strText := 'Possible Paper Jam';
SIf.Alm[E_ALM_PBC.DoublePaperError].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_PBC.DoublePaperError].strText := 'Double paper detected';
SIf.Alm[E_ALM_PBC.DataChannelBufferFull].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[E_ALM_PBC.DataChannelBufferFull].strText := 'Data Channel buffer is full';
SIf.Alm[E_ALM_PBC.DataChannelSend].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[E_ALM_PBC.DataChannelSend].strText := 'Data Channel item could not be sent';
SIf.Alm[E_ALM_PBC.PaperInject].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_PBC.PaperInject].strText := 'Paper is not transported to the front';
SIf.Alm[E_ALM_PBC.PaperInjectRetry].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[E_ALM_PBC.PaperInjectRetry].strText := 'Paper transport retry';
SIf.Alm[E_ALM_PBC.DoNotReleaseItems].eAlmClass := E_AlmClass.INFO;
SIf.Alm[E_ALM_PBC.DoNotReleaseItems].strText := 'Currently not releasing items because in manual mode';
SIf.Alm[E_ALM_PBC.DoublePaperWarning].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[E_ALM_PBC.DoublePaperWarning].strText := 'Double paper detected';

//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolEnable := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// Configuration
SIf.Cfg.bolUseTurnTableSensorForEject 		:= TRUE;
SIf.Cfg.bolEnableDataChannel		  		:= FALSE;
SIf.Cfg.bolGranulatAirPressureUnitAvailable := FALSE;
SIf.Cfg.bolEnableSaberStopDeStack 			:= TRUE;

// parameter
SIf.Par.bolAutomaticMode := TRUE;
SIf.Par.bolStopReleaseItems := FALSE;
SIf.Par.udiPaperTransportTime := 3000;
SIf.Par.udiSheetToEject := 0;
SIf.Par.udiSheetToSheetTime := 22800;
SIf.Par.udiManualSheetToSheetTime_ms := 22800;
SIf.Par.udiPaperInjectRetryPauseTime_ms := 400;
SIf.Par.udiPaperInjectRetries := 3;
SIf.Par.udiDoublePaperDebounceTime_ms := 500;
SIf.Par.bolEnableDoublePaperDetection := FALSE;
SIf.Par.udiSimPaperTransportTime := SIf.Par.udiPaperTransportTime / 2;
SIf.Par.udiSimPaperToPaperTransportTime := SIf.Par.udiPaperTransportTime / 20;

_eStopReason := E_STOPREASON.None;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNbusy" Id="{f79a7d8e-64ea-4d3d-b892-ec6b47521d55}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUNbusy'}
METHOD PROTECTED sta_RUNbusy : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	IF (CIf.SwCfg.bolSimulation) THEN
		SIf.In.bolCapacityReached.intern := FALSE;
		SIf.In.bolPaperAvailableEntry.intern := TRUE;
		SIf.In.bolPaperAvailableExit.intern := TRUE;
	END_IF

	SIf.Out.bolAirOn.intern := TRUE;
	
	_pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
	_pBeltCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
	_pBccCIf^.Job.intACmd := cCMD_OFF;
	
	// clear alarm
	pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.DoNotReleaseItems),0,ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	IF (_pBeltCIf^.Job.intState = cSTA_RUN) AND (_pBccCIf^.Job.intState = cSTA_OFF) THEN
		IF SIf.Par.bolAutomaticMode THEN
			SIf.Cur.uinPaperToEjectParameter := 0;
			SIf.Cur.uinPaperToEjectCount := 0;
			me.StateMachine.intStateNext := BASE_PLC.cSTA_RUN;
		ELSE	
			IF me.intCmd = PBC_CmdState.cCMD_SINGLE THEN
				SIf.Cur.uinPaperToEjectParameter := 1;
				SIf.Cur.uinPaperToEjectCount := 1;
		
				IF NOT SIf.In.bolPaperAvailableExit.intern AND NOT SIf.In.bolPaperAvailableEntry.intern THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.BufferEmpty),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				END_IF
		
				me.StateMachine.intStateNext := BASE_PLC.cSTA_RUN;
			ELSE
				SIf.Cur.uinPaperToEjectParameter := UDINT_TO_UINT(SIf.Par.udiSheetToEject);
				SIf.Cur.uinPaperToEjectCount := UDINT_TO_UINT(SIf.Par.udiSheetToEject);
		
				IF SIf.Par.udiSheetToEject > 0 THEN
					me.StateMachine.intStateNext := BASE_PLC.cSTA_RUN;
				ELSE
					CIf.Job.intACmd := cCMD_DONE;
					CIf.Job.intMCmd := cCMD_DONE;
					me.StateMachine.intStateNext := BASE_PLC.cSTA_STANDBYBusy;
				END_IF
			END_IF
		END_IF
	END_IF
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	;
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>