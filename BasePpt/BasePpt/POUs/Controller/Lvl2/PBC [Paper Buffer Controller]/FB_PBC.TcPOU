<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.19">
  <POU Name="FB_PBC" Id="{745ceb7b-22fd-45b0-b46c-f7e5c491017a}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PBC EXTENDS FB_CtrlBase
VAR_INPUT
	In_bolPaperAvailableExit			: BOOL;
	In_bolPaperAvailableEntry			: BOOL;
	In_bolCapacityReached				: BOOL;
END_VAR
VAR_OUTPUT
	Out_bolAirOn						: BOOL;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf									: T_Ctrl_SIf_PBC;
	///pointer to function block
	p_fbDeStacker					: POINTER TO FB_PTB;
	pDeStackerCIf					: POINTER TO BASE_PLC.T_Ctrl_CIf;
	p_fbBelt						: POINTER TO FB_PTB;
	pBeltCIf						: POINTER TO BASE_PLC.T_Ctrl_CIf;


	m_uinPaperHight_mm			: UINT := 460;
	m_uinPaperWidth_mm			: UINT := 320;
END_VAR
VAR CONSTANT
	cPAPERPOSITION_TOLERANCE_mm		: UINT := 200;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Destacker/Buffer implementation. 


History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		09.07.2013		PC			Start history
___________________________________________________________________________________________________*)


IF (me.bolActivate) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
END_IF;
]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{43af98e9-0fd6-4315-b49a-4d4484fe858a}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
VAR
	iIdx		: UINT;
	iLength		: UINT;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
iLength := SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0]);
iIdx := 0;

WHILE (iIdx < iLength) AND (CIf.Job.aCmdList[iIdx].intCmd <> cCMD_INITIALIZED) DO
	iIdx := iIdx + 1; 
END_WHILE

IF (iIdx < iLength) THEN
// Add configuration of own comands	
	CIf.Job.aCmdList[iIdx].intCmd := BASE_PLC.cCMD_RUN;
	CIf.Job.aCmdList[iIdx].strName := 'RUN'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := BASE_PLC.cCMD_STOP;
	CIf.Job.aCmdList[iIdx].strName := 'STOP'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := PBC_CmdState.cCMD_SINGLE;
	CIf.Job.aCmdList[iIdx].strName := 'SINGLE'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
	iIdx := iIdx + 1;
	CIf.Job.aCmdList[iIdx].intCmd := PBC_CmdState.cCMD_STANDBY;
	CIf.Job.aCmdList[iIdx].strName := 'STANDBY'; 
	CIf.Job.aCmdList[iIdx].bolAvailable := TRUE;
ELSE
	// Error if the aCmdList Array is to small
END_IF

// set name of class/typ
CIf.Info.strType := 'FB_PBC'; 

// set alarm class
SIf.Alm[E_ALM_PBC.BufferEmpty].eAlmClass := Base_PLC.E_AlmClass.WARNING;
SIf.Alm[E_ALM_PBC.BufferEmpty].strText := 'Buffer is Empty'; 
SIf.Alm[E_ALM_PBC.BufferFull].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_PBC.BufferFull].strText := 'Buffer reached capacity limit';
SIf.Alm[E_ALM_PBC.PaperTransport].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_PBC.PaperTransport].strText := 'Possible Paper Jam';

//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolEnable := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// parameter
SIf.Par.udiPaperTransportTime := 3000;
SIf.Par.udiSheetToEject := 1;
SIf.Par.udiSheetToSheetTime := 5000;
SIf.Par.udiSimPaperTransportTime := SIf.Par.udiPaperTransportTime / 2;
SIf.Par.udiSimPaperToPaperTransportTime := SIf.Par.udiPaperTransportTime / 20;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{5df45b51-408f-4249-8078-bdbe370cd5fd}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	; // always error supervision
	
END_IF

// ----------------------------------------------------------------------------------
// Conditions Always
IF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.Alarm.eActivAlmClass=E_AlmClass.OFF) OR (me.intCmd=cCMD_OFF))
		 AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) AND
		(me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)) THEN
	// alarm evt EOFF, OFF or cmd off
	me.StateMachine.intStateNext := cSTA_OFFBusy;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{96a8adaa-ba85-4708-bf41-3b06dc9f583b}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING

VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states

IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		CASE intCmdState OF
			PBC_CmdState.cCMD_SINGLE: 
				getCmdState := 'cCMD_SINGLE';
			PBC_CmdState.cCMD_STANDBY: 
				getCmdState := 'cCMD_STANDBY';
		END_CASE;
	ELSE
		// States's
		CASE intCmdState OF
			PBC_CmdState.cSTA_STANDBYBusy: 
				getCmdState := 'cSTA_STANDBYBusy';
			PBC_CmdState.cSTA_STANDBY: 
				getCmdState := 'cSTA_STANDBY';
			PBC_CmdState.cSTA_EjectBusy: 
				getCmdState := 'cSTA_EjectBusy';
			PBC_CmdState.cSTA_EjectCheck: 
				getCmdState := 'cSTA_EjectCheck';
			PBC_CmdState.cSTA_PositionPaperBusy: 
				getCmdState := 'cSTA_PositionPaperBusy';
			PBC_CmdState.cSTA_RUNEmpty: 
				getCmdState := 'cSTA_RUNEmpty';
			PBC_CmdState.cSUB_WAITPAPER: 
				getCmdState := 'WAITPAPER';
			PBC_CmdState.cSUB_EJECTSTARTbusy: 
				getCmdState := 'EJECTSTARTbusy';
			PBC_CmdState.cSUB_EJECTbusy: 
				getCmdState := 'EJECTbusy';

			PBC_CmdState.cSUB_EJECTSTOPbusy: 
				getCmdState := 'EJECTSTOPbusy';
			PBC_CmdState.cSUB_EVALUATEEJECT: 
				getCmdState := 'EVALUATEEJECT';
			PBC_CmdState.cSUB_POSITIONbusy: 
				getCmdState := 'POSITIONbusy';

			PBC_CmdState.cSUB_POSITIONSTARTbusy: 
				getCmdState := 'POSITIONSTARTbusy';
			PBC_CmdState.cSUB_POSITIONSTOPbusy: 
				getCmdState := 'POSITIONSTOPbusy';
			PBC_CmdState.cSUB_READYEJECT: 
				getCmdState := 'READYEJECT';
		END_CASE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{340f75bf-a171-4e14-80ea-f263d49e20d6}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_PBC

]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{b4c34e00-7387-4a89-93cd-155ecb5970b0}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
SIf.In.bolCapacityReached.map			:= THIS^.In_bolCapacityReached				;
SIf.In.bolPaperAvailableEntry.map		:= THIS^.In_bolPaperAvailableEntry	;
SIf.In.bolPaperAvailableExit.map		:= THIS^.In_bolPaperAvailableExit		;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolCapacityReached));
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolPaperAvailableEntry));
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolPaperAvailableExit));
ELSE
;	//simulation of global IO
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{09605759-0675-49c0-b9f9-1bcb61c08f7a}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
VAR
	bolSwitchValvesOff: BOOL;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{28df19a1-7fba-4285-ab71-123ea0136e01}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		pDeStackerCIf^.Job.intACmd 	:= BASE_PLC.cCMD_STOP;
		//pBeltCIf^.Job.intACmd 		:= BASE_PLC.cCMD_STOP;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERRORQuit" Id="{83e29956-15ea-4550-b6c0-49d686f2c14e}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERRORQuit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		// evtl. wait time if reset of device is necessary and then decide to go to states or ERROR state
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
			CIf.Job.bolAlmReset := FALSE;
		END_IF
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = FALSE) THEN
			IF (me.StateMachine.intStateHistory<=BASE_PLC.cSTA_PON) THEN
				me.StateMachine.intStateNext := BASE_PLC.cSTA_PONBusy;
			END_IF;

			CASE me.intCmd OF
				BASE_PLC.cCMD_OFF:
					me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
				PBC_CmdState.cCMD_STANDBY:
					me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
				PBC_CmdState.cCMD_SINGLE,
				BASE_PLC.cCMD_RUN:
					me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
			ELSE
				CASE me.StateMachine.intStateHistory OF
					PBC_CmdState.cSTA_STANDBY:
						me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
					BASE_PLC.cSTA_RUN:
						me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
				END_CASE
			END_CASE
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{8e5f6b90-d7f9-4cce-a044-4dda6aa3dd9d}">
      <Declaration><![CDATA[METHOD PROTECTED sta_PON : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		;
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{e76e448b-7d3c-411c-8e5f-f01dfe94ab51}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFFBusy : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_OFF;
		pBeltCIf^.Job.intACmd := BASE_PLC.cCMD_OFF;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		IF (pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_OFF)
		  AND (pBeltCIf^.Job.intState = BASE_PLC.cSTA_OFF) THEN
			me.StateMachine.intStateNext := BASE_PLC.cSTA_OFF;
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{ea23bc49-a15a-46c6-b96e-9fac96c2a25c}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		CASE me.intCmd OF
			BASE_PLC.cCMD_RUN : 
				me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
			PBC_CmdState.cCMD_STANDBY : 
				me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
		END_CASE
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{5b73e8e9-f044-4d9b-b2fd-2e659eceb290}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL

]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
    PBC_CmdState.cSTA_EjectBusy: 
        THIS^.sta_EjectBusy();
    PBC_CmdState.cSTA_EjectCheck: 
        THIS^.sta_EjectCheck();
    PBC_CmdState.cSTA_PositionPaperBusy: 
        THIS^.sta_PositionPaperBusy();
    PBC_CmdState.cSTA_STANDBYBusy: 
        THIS^.sta_STANDBYBusy();
    PBC_CmdState.cSTA_STANDBY: 
        THIS^.sta_STANDBY();
	BASE_PLC.cSTA_RUN:
		THIS^.sta_RUN();
	BASE_PLC.cSTA_RUNBusy:
		THIS^.sta_RUNbusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PositionPaperBusy" Id="{8f474f90-b81f-445c-8917-2ebaa0e092d1}">
      <Declaration><![CDATA[METHOD PROTECTED sta_PositionPaperBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	CIf.Job.intACmd := BASE_PLC.cCMD_DONE;
	CIf.Job.intMCmd := BASE_PLC.cCMD_DONE;
	
	IF NOT SIf.In.bolPaperAvailableExit.intern THEN
		pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
	END_IF

	me.SubStateMachine.intState := PBC_CmdState.cSUB_WAITPAPER;
	me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;

// - SIMULATION ------------------------------------------------------------------------------------------- 		
	IF CIf.SwCfg.bolSimulation THEN
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udiSimPaperToPaperTransportTime);
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
	END_IF
// -------------------------------------------------------------------------------------------- 		
END_IF


//-------------------------------------------------------------------------------------- 
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
// - SIMULATION ------------------------------------------------------------------------------------------- 		
	IF (CIf.SwCfg.bolSimulation) THEN
		fbSimulationTimer(); // simulation time

		IF (fbSimulationTimer.Q) THEN
			SIf.In.bolPaperAvailableExit.intern := TRUE;
		END_IF
	END_IF
// -------------------------------------------------------------------------------------------- 		

	CASE me.SubStateMachine.intState OF
		PBC_CmdState.cSUB_STARTDRIVE:
			pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
			me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
			
		PBC_CmdState.cSUB_WAITPAPER:
			IF SIf.In.bolPaperAvailableExit.intern THEN
				pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITSTOP;
			END_IF

			IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiPaperTransportTime) THEN
				IF SIf.Cur.bolPaperBeforeEjectAvailable THEN
					g_fbAlm_Man.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperTransport),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;	
				ELSE
					pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
					me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
				END_IF
			END_IF
			
		PBC_CmdState.cSUB_WAITSTOP:
			IF pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP THEN
				me.StateMachine.intStateNext := PBC_CmdState.cSTA_EjectCheck;
			END_IF			
	END_CASE
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	me.SubStateMachine.intState := BASE_PLC.cSTA_INITIALIZED;
	me.SubStateMachine.intStateNext := BASE_PLC.cSTA_INITIALIZED;
END_IF
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EjectBusy" Id="{dd4b6ee6-b2c2-467c-bbd2-45ab3f14f938}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EjectBusy : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;

	SIf.Cur.bolPaperBeforeEjectAvailable := SIf.In.bolPaperAvailableEntry.intern;
	SIf.Cur.uinPaperToPaperTime_ms := UDINT_TO_UINT((m_uinPaperHight_mm + 100) * 1000 / p_fbDeStacker^.CtrlSIf^.Par.rBeltParam.uinBeltSpeed);

// - SIMULATION ------------------------------------------------------------------------------------------- 		
	IF CIf.SwCfg.bolSimulation THEN
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udiSimPaperTransportTime);
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
	END_IF
// -------------------------------------------------------------------------------------------- 		
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

// - SIMULATION ------------------------------------------------------------------------------------------- 		
	IF (CIf.SwCfg.bolSimulation) THEN
		fbSimulationTimer(); // simulation time

		IF (fbSimulationTimer.Q) THEN
			SIf.In.bolPaperAvailableExit.intern := FALSE;
		END_IF
	END_IF
// -------------------------------------------------------------------------------------------- 		

	IF NOT SIf.In.bolPaperAvailableExit.intern THEN
		IF SIf.Cur.uinPaperToEjectParameter > 0 THEN
			SIf.Cur.uinPaperToEjectCount := SIf.Cur.uinPaperToEjectCount - 1;
		END_IF

		IF SIf.Cur.bolPaperBeforeEjectAvailable THEN
			me.StateMachine.intStateNext := PBC_CmdState.cSTA_PositionPaperBusy;
		ELSE
			me.StateMachine.intStateNext := PBC_CmdState.cSTA_EjectCheck;
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.BufferEmpty),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		END_IF
	END_IF

	IF (me.StateMachine.udiTimeInState_ms > SIf.Cur.uinPaperToPaperTime_ms) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperTransport),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;	
	END_IF
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EjectCheck" Id="{56bfc1f7-bf09-442f-a91f-6bf7d793cf01}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EjectCheck : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
//		SIf.Cur.bolPaperBeforeEjectAvailable := SIf.In.bolPaperAvailableEntry.intern;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		// Eject next paper if there are still paper to edject or endless ejection
		IF (SIf.Cur.uinPaperToEjectCount > 0) OR (SIf.Cur.uinPaperToEjectParameter = 0) THEN
			// Make a delay from sheet to sheet if it is not the first sheet
			IF   (SIf.Cur.uinSheetToSheetTime > SIf.Par.udiSheetToSheetTime) 
			  OR (SIf.Cur.uinPaperToEjectCount = SIf.Cur.uinPaperToEjectParameter) THEN
				IF SIf.In.bolPaperAvailableExit.intern THEN
					SIf.Cur.uinSheetToSheetTime := 0;
					me.StateMachine.intStateNext := PBC_CmdState.cSTA_EjectBusy;
				ELSE
					IF SIf.In.bolPaperAvailableEntry.intern THEN
						me.StateMachine.intStateNext := PBC_CmdState.cSTA_PositionPaperBusy;
					END_IF
				END_IF
			END_IF
		ELSE
			me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
		END_IF

		CASE me.intCmd OF
			BASE_PLC.cCMD_STOP:
				me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
			PBC_CmdState.cCMD_STANDBY:
				me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
		END_CASE
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBYBusy" Id="{c4de4e01-268c-41c5-8be2-8b673f3a3ba9}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STANDBYBusy : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		SIf.Cur.uinPaperToEjectParameter := 0;
		SIf.Cur.uinPaperToEjectCount := 0;
	
		IF NOT SIf.In.bolPaperAvailableEntry.intern THEN
			SIf.Cur.uinPaperInBufferCount := 0;
		END_IF
		
		IF (CIf.SwCfg.bolSimulation) THEN
			SIf.In.bolCapacityReached.intern := FALSE;
			SIf.In.bolPaperAvailableEntry.intern := TRUE;
			SIf.In.bolPaperAvailableExit.intern := TRUE;
		END_IF
	
		pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
		pBeltCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		IF (pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP)
		  AND (pBeltCIf^.Job.intState = BASE_PLC.cSTA_RUN)  THEN
			me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBY;
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STANDBY" Id="{c682bfe9-1a1d-4118-9d1d-f22a90320ab2}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STANDBY : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	
	IF me.intCmd = PBC_CmdState.cCMD_STANDBY THEN
		CIf.Job.intACmd := BASE_PLC.cCMD_DONE;
		CIf.Job.intMCmd := BASE_PLC.cCMD_DONE;
	END_IF
	
	me.SubStateMachine.intState 	:= PBC_CmdState.cSUB_POSITIONSTARTbusy;
	me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState = me.StateMachine.intStateLastCycle) THEN
	CASE me.SubStateMachine.intState OF
		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_WAITPAPER:
			IF SIf.In.bolPaperAvailableExit.intern THEN
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_READYEJECT;
			ELSE
				IF SIf.In.bolCapacityReached.intern THEN
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
				END_IF
			END_IF
			
		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_POSITIONSTARTbusy:
			IF NOT SIf.In.bolPaperAvailableExit.intern THEN
				SIf.Cur.bolPaperBeforeEjectAvailable := SIf.In.bolCapacityReached.intern;
				pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONbusy;
			ELSE
				me.SubStateMachine.intStateNext := cSUB_READYEJECT;
			END_IF

		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_POSITIONbusy:
			IF me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiPaperTransportTime THEN
				IF SIf.Cur.bolPaperBeforeEjectAvailable THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperTransport),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;	
				ELSE
					pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTOPbusy;
				END_IF 
			ELSE
				IF SIf.In.bolPaperAvailableExit.intern THEN
					pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTOPbusy;
				END_IF
			END_IF

		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_POSITIONSTOPbusy:
			IF pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP THEN
				IF SIf.In.bolPaperAvailableExit.intern THEN
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_READYEJECT;
				ELSE
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
				END_IF
			END_IF
		PBC_CmdState.cSUB_READYEJECT:
			IF NOT SIf.In.bolPaperAvailableExit.intern THEN
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
			END_IF
	END_CASE

	CASE me.SubStateMachine.intState OF
		PBC_CmdState.cSUB_WAITPAPER,
		PBC_CmdState.cSUB_READYEJECT:
			IF me.intCmd = PBC_CmdState.cCMD_SINGLE THEN
				SIf.Cur.uinPaperToEjectParameter := 1;
				SIf.Cur.uinPaperToEjectCount := 1;

				IF NOT SIf.In.bolPaperAvailableExit.intern AND NOT SIf.In.bolPaperAvailableEntry.intern THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.BufferEmpty),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				END_IF

				me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
			END_IF
		
			IF me.intCmd = BASE_PLC.cCMD_RUN THEN
				SIf.Cur.uinPaperToEjectParameter := UDINT_TO_UINT(SIf.Par.udiSheetToEject);
				SIf.Cur.uinPaperToEjectCount := UDINT_TO_UINT(SIf.Par.udiSheetToEject);

				IF NOT SIf.In.bolPaperAvailableExit.intern AND NOT SIf.In.bolPaperAvailableEntry.intern THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.BufferEmpty),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				END_IF

				me.StateMachine.intStateNext := BASE_PLC.cSTA_RUNBusy;
			END_IF
	END_CASE
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	me.SubStateMachine.intState 	:= BASE_PLC.cSTA_INITIALIZED;
	me.SubStateMachine.intStateNext := BASE_PLC.cSTA_INITIALIZED;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{ec0b4ded-ed68-4fff-9fa4-805d4f9700a2}">
      <Declaration><![CDATA[METHOD PROTECTED CtrlInit : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

pDeStackerCIf 	:= p_fbDeStacker^.CtrlCIf;
pBeltCIf 		:= p_fbBelt^.CtrlCIf;

AddChild(p_fbDeStacker^);
AddChild(p_fbBelt^);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CountPaper" Id="{52ff7394-30af-43ff-9cdb-b2b5d861171f}">
      <Declaration><![CDATA[METHOD PROTECTED CountPaper : UINT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNbusy" Id="{e3863175-d02c-4e5a-8668-4d034780dc8e}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNbusy : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	
	pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
	pBeltCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateNext := BASE_PLC.cSTA_RUN;
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{66582854-f31f-4726-acba-5f09fc01e7a0}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
VAR
	uditest			: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	CIf.Job.intACmd := BASE_PLC.cCMD_DONE;
	CIf.Job.intMCmd := BASE_PLC.cCMD_DONE;
	
	SIf.Cur.uinSheetToSheetTime := 0;
	
	me.SubStateMachine.intState 	:= PBC_CmdState.cSUB_POSITIONSTARTbusy;
	me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	CASE me.SubStateMachine.intState OF
		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_WAITPAPER:
			IF SIf.In.bolPaperAvailableExit.intern THEN
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EVALUATEEJECT;
			ELSE
				IF SIf.In.bolCapacityReached.intern THEN
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
				END_IF
			END_IF
			
		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_POSITIONSTARTbusy:
			IF NOT SIf.In.bolPaperAvailableExit.intern THEN
				SIf.Cur.bolPaperBeforeEjectAvailable := SIf.In.bolCapacityReached.intern;
				pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONbusy;
			ELSE
				me.SubStateMachine.intStateNext := cSUB_EVALUATEEJECT;
			END_IF

		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_POSITIONbusy:
			IF me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiPaperTransportTime THEN
				IF SIf.Cur.bolPaperBeforeEjectAvailable THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperTransport),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;	
				ELSE
					pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTOPbusy;
				END_IF 
			ELSE
				IF SIf.In.bolPaperAvailableExit.intern THEN
					pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTOPbusy;
				END_IF
			END_IF

		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_POSITIONSTOPbusy:
			IF pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP THEN

				IF SIf.In.bolPaperAvailableExit.intern THEN
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EVALUATEEJECT;
				ELSE
					me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
				END_IF
			END_IF

		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_EVALUATEEJECT:
			// Eject next paper if there are still paper to edject or endless ejection
			IF (SIf.Cur.uinPaperToEjectCount > 0) OR (SIf.Cur.uinPaperToEjectParameter = 0) THEN
				// Make a delay from sheet to sheet if it is not the first sheet
				IF   (SIf.Cur.uinSheetToSheetTime > SIf.Par.udiSheetToSheetTime) 
				  OR (SIf.Cur.uinPaperToEjectCount = SIf.Cur.uinPaperToEjectParameter) THEN
					SIf.Cur.uinSheetToSheetTime := 0;

					IF SIf.In.bolPaperAvailableExit.intern THEN
						me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EJECTSTARTbusy;
					ELSE
						me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_WAITPAPER;
					END_IF
				END_IF
			ELSE
				me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
			END_IF

		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_EJECTSTARTbusy:
			pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_RUN;
			SIf.Cur.uinPaperToPaperTime_ms := UDINT_TO_UINT((m_uinPaperHight_mm + 100) * 1000 / p_fbDeStacker^.CtrlSIf^.Par.rBeltParam.uinBeltSpeed);
			uditest := 0;
			me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EJECTbusy;

		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_EJECTbusy:
			IF uditest = 0 THEN
				uditest := me.SubStateMachine.udiTimeInState_ms;
			END_IF
			
			IF NOT SIf.In.bolPaperAvailableExit.intern THEN
				pDeStackerCIf^.Job.intACmd := BASE_PLC.cCMD_STOP;
				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_EJECTSTOPbusy;
			END_IF
			
			IF (me.SubStateMachine.udiTimeInState_ms > SIf.Cur.uinPaperToPaperTime_ms) THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UINT(E_ALM_PBC.PaperTransport),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;	
			END_IF

		// substate Wait paper - wait for the next paper if the buffer was empty
		// ------------------------------------------------------------------------
		PBC_CmdState.cSUB_EJECTSTOPbusy:
			IF pDeStackerCIf^.Job.intState = BASE_PLC.cSTA_STOP THEN
				IF SIf.Cur.uinPaperToEjectCount > 0 THEN
					SIf.Cur.uinPaperToEjectCount := SIf.Cur.uinPaperToEjectCount - 1;
				END_IF

				me.SubStateMachine.intStateNext := PBC_CmdState.cSUB_POSITIONSTARTbusy;
			END_IF
	END_CASE
	
	IF me.intCmd = PBC_CmdState.cCMD_STANDBY THEN
		CASE me.SubStateMachine.intState OF
			PBC_CmdState.cSUB_WAITPAPER,
			PBC_CmdState.cSUB_EVALUATEEJECT:
				me.StateMachine.intStateNext := PBC_CmdState.cSTA_STANDBYBusy;
		END_CASE
	END_IF
	
	SIf.Cur.uinSheetToSheetTime := UDINT_TO_UINT(SIf.Cur.uinSheetToSheetTime + me.FUBInfo.udiSample_ms);
END_IF


//--------------------------------------------------------------------------------------
// Exit action
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	me.SubStateMachine.intState 	:= BASE_PLC.cSTA_INITIALIZED;
	me.SubStateMachine.intStateNext := BASE_PLC.cSTA_INITIALIZED;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="CtrlSIf" Id="{c4c6700e-5e4a-4c8f-a197-eae05e779dd4}">
      <Declaration><![CDATA[PROPERTY PUBLIC CtrlSIf : POINTER TO T_Ctrl_SIf_PBC]]></Declaration>
      <Get Name="Get" Id="{ee9f4767-dc48-4c1f-ab92-2d208c450b1b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[CtrlSIf := ADR(SIf);]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{3d0bd609-2778-4f2e-85bc-259775f82179}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="DeStacker" Id="{b5015bf2-b411-4341-968f-94b5e46a53f5}">
      <Declaration><![CDATA[PROPERTY PUBLIC DeStacker :  POINTER TO FB_PTB]]></Declaration>
      <Get Name="Get" Id="{7fc50074-74db-426c-bb74-308edbac73fa}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[DeStacker := p_fbDeStacker;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{33a0d56c-bf25-4d65-879e-4c0af40e0c0b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[p_fbDeStacker := DeStacker;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="Belt" Id="{f87305b3-223a-48a5-9713-2c80a684a145}">
      <Declaration><![CDATA[PROPERTY PUBLIC Belt :  POINTER TO FB_PTB]]></Declaration>
      <Get Name="Get" Id="{1e07931d-5c23-42b6-8736-ca3db5172445}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Belt := p_fbBelt;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{0a53fc97-cb33-491e-9455-6421605bf69b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[p_fbBelt := Belt;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="PaperHight" Id="{527c0037-a43f-46c9-a6ae-e6ceddd0ccaf}">
      <Declaration><![CDATA[PROPERTY PUBLIC PaperHight : UINT]]></Declaration>
      <Get Name="Get" Id="{e5b9a80b-8505-4d0e-8c0c-f9d0c54e2c70}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[PaperHight := m_uinPaperHight_mm;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{8ff9c6f1-ad65-4413-9c10-6e3c5fd77222}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_uinPaperHight_mm := PaperHight;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="PaperWidth" Id="{44d21eca-9323-46d0-845a-a7e1e74db448}">
      <Declaration><![CDATA[PROPERTY PUBLIC PaperWidth : UINT]]></Declaration>
      <Get Name="Get" Id="{6380a29d-3892-469a-a6f5-c65dc88c20a5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[PaperWidth := m_uinPaperWidth_mm;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{1569bb1c-d900-456d-b20d-84c3b85dd393}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_uinPaperWidth_mm := PaperWidth;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <ObjectProperties>﻿<XmlArchive>
  <Data>
    <o xml:space="preserve" t="POUImageProperty">
      <n n="ImageData" />
      <v n="TransparencyColor">"White"</v>
      <v n="MakeTransparent">false</v>
    </o>
  </Data>
  <TypeList>
    <Type n="Boolean">System.Boolean</Type>
    <Type n="POUImageProperty">{bb741845-1ec5-4be9-bb0d-2cf7058af574}</Type>
    <Type n="String">System.String</Type>
  </TypeList>
</XmlArchive></ObjectProperties>
  </POU>
</TcPlcObject>