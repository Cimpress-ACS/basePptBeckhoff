<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.25">
  <POU Name="FB_IBH" Id="{b0e34786-1945-4fbf-ba31-18ca8b1b1f1d}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_IBH EXTENDS FB_CtrlBase
VAR_OUTPUT
	/// Status 
	Out_iStatus: INT;
	/// Machine off 
	Out_bOff: BOOL;
	/// Band on 
	Out_bBeltOn: BOOL;
	/// Manual Mode 
	Out_bManual: BOOL;
	/// Standart drying process 
	Out_bRun: BOOL;
	/// Set Parameter 
	Out_bSetParam: BOOL;
	/// Get Parameter 
	Out_bGetParam: BOOL;
	/// Resetting error 
	Out_bAckError: BOOL;
	/// Actual temperature in deci °C 
	Out_adiTemp_dc: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Aactual airflow in % 
	Out_adiAir_p: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Actual belt speed in mm/min 
	Out_diSpeed_mm_min: DINT;
	/// 1=Information, 2=Warning, 3=Error 
	Out_iErrorLevel: INT;
	/// Error ID (e.g. 100=temperature overflow) 
	Out_iErrorID: INT;
	Out_bDriverConnected: BOOL;
	Out_bDriverError: BOOL;
	Out_udiDriverErrorID: UDINT;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_IBH;
	/// Turns oven off 
	iOff: INT;
	/// Turns belt on 
	iBeltOn: INT;
	/// Puts oven to manual  
	iManual: INT;
	/// Standart drying process 
	iRun: INT;
	/// Set Parameter 
	iSetParam: INT;
	/// Get Parameter 
	iGetParam: INT;
	/// Temperature in deci °C 
	adiTemp_dc: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Airflow in % 
	adiAir_p: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Belt speed in mm/min 
	diSpeed_mm_min: DINT;
	/// Try to reset error 
	iAckError: INT;
	bIncrementSetParam: BOOL;
	bRememberIncrementSetParam: BOOL;
	fbOpen: Tc2_S5S7Com.FB_NLinkOpen;
	fbWrite: Tc2_S5S7Com.FB_NLinkWrite;
	fbFetch: Tc2_S5S7Com.FB_NLinkFetch;
	fbClose: Tc2_S5S7Com.FB_NLinkClose;
	/// Communication link handle 
	hLink: T_HNLINK;
	/// read data buffer 
	anReadBuffer: ARRAY[0..(READ_BUFFER_LENGTH - 1)] OF BYTE;
	/// data to write 
	anWriteBuffer: ARRAY[0..(WRITE_BUFFER_LENGTH - 1)] OF BYTE;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
IBH Link Connection Implementation

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		09.01.2014		BB			Start history
___________________________________________________________________________________________________*)

SUPER^();]]></ST>
    </Implementation>
    <Method Name="sta_OFF" Id="{079a83bc-f368-473d-9a58-2d5eacbc7942}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFF'}
METHOD PROTECTED sta_OFF : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	IF CIf.SwCfg.bolEnable THEN
		CASE me.intCmd OF
			// CONNECT
			IBH_CmdState.cCMD_CONNECT, IBH_CmdState.cCMD_WRITE, IBH_CmdState.cCMD_READ:
				me.StateMachine.intStateNext := IBH_CmdState.cSTA_CONNECTBusy;
		ELSE
			// DEFAULT
			;
		END_CASE
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{08684d9c-e6b9-47e2-aa66-b28ab5b7c8a7}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PON'}
METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
	

// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{0accaec6-7a10-4d05-90a8-2093259b81bc}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CtrlInit'}
METHOD CtrlInit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// add childs
// ...]]></ST>
      </Implementation>
    </Method>
    <Method Name="setTemp" Id="{12b4e731-abaa-42a5-a1ec-d738ad8ef065}">
      <Declaration><![CDATA[{attribute 'object_name' := 'setTemp'}
METHOD setTemp
VAR_INPUT
	/// Temperature in deci °C 
	In_adiTemp_dc: ARRAY[1..MAX_NUMBER_OF_OVEN_MODULES] OF DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[adiTemp_dc := In_adiTemp_dc;
bIncrementSetParam := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{1e98861f-0bc6-4fd1-8c68-a6e91c74e1a0}">
      <Declaration><![CDATA[{attribute 'object_name' := 'FB_init'}
METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR uiIdx:=0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[uiIdx].intCmd=cSTA_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

// Add configuration of own comands
CIf.Job.aCmdList[uiIdx].intCmd := IBH_CmdState.cCMD_CONNECT;
CIf.Job.aCmdList[uiIdx].strName := 'CONNECT';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;
uiIdx := uiIdx+1;
CIf.Job.aCmdList[uiIdx].intCmd := IBH_CmdState.cCMD_WRITE;
CIf.Job.aCmdList[uiIdx].strName := 'WRITE';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;
uiIdx := uiIdx+1;
CIf.Job.aCmdList[uiIdx].intCmd := IBH_CmdState.cCMD_READ;
CIf.Job.aCmdList[uiIdx].strName := 'READ';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;
uiIdx := uiIdx+1;
CIf.Job.aCmdList[uiIdx].intCmd := IBH_CmdState.cCMD_DISCONNECT;
CIf.Job.aCmdList[uiIdx].strName := 'DISCONNECT';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_IBH';
CIf.Info.strFullName := 'IBH Link';

//*******************************************************************************
// initial values
//*******************************************************************************

// Software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolEnable := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// Internal Variables (Input)
iOff := 0;
iBeltOn := 0;
iManual := 0;
iRun := 0;
iSetParam := 0;
iGetParam := 0;
FOR uiIdx:=0 TO MAX_NUMBER_OF_OVEN_MODULES-1 BY 1 DO
	adiTemp_dc[uiIdx] := 0;
	adiAir_p[uiIdx] := 0;
END_FOR
diSpeed_mm_min := 0;
iAckError := 0;
bIncrementSetParam := FALSE;
bRememberIncrementSetParam := FALSE;

// Configuration
SIf.Cfg.tIpAddress						:= '192.168.0.50';
SIf.Cfg.udiPortAdress					:= 1099;
SIf.Cfg.nDeviceAddress					:= 2;
SIf.Cfg.nDatablockNumber				:= 22;
SIf.Cfg.tTimeout						:= T#15S;

SIf.Cfg.nWriteStartAddress				:= 0;
SIf.Cfg.nReadStartAddress				:= 110;

SIf.Cfg.uiByteOffset_rd_iStatus			:= 0;
SIf.Cfg.uiByteOffset_rd_bOff			:= 10;
SIf.Cfg.uiBitOffset_rd_bOff				:= 0;
SIf.Cfg.uiByteOffset_rd_bBeltOn			:= 10;
SIf.Cfg.uiBitOffset_rd_bBeltOn			:= 1;
SIf.Cfg.uiByteOffset_rd_bManual			:= 10;
SIf.Cfg.uiBitOffset_rd_bManual			:= 2;
SIf.Cfg.uiByteOffset_rd_bRun			:= 10;
SIf.Cfg.uiBitOffset_rd_bRun				:= 3;
SIf.Cfg.uiByteOffset_rd_bSetParam		:= 10;
SIf.Cfg.uiBitOffset_rd_bSetParam		:= 4;
SIf.Cfg.uiByteOffset_rd_bGetParam		:= 10;
SIf.Cfg.uiBitOffset_rd_bGetParam		:= 5;
SIf.Cfg.uiByteOffset_rd_bAckError		:= 10;
SIf.Cfg.uiBitOffset_rd_bAckError		:= 6;
SIf.Cfg.uiByteOffset_rd_adiTemp_mc		:= 30;
SIf.Cfg.uiByteOffset_rd_adiAir_p		:= 62;
SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min	:= 94;
SIf.Cfg.uiByteOffset_rd_iErrorLevel		:= 98;
SIf.Cfg.uiByteOffset_rd_iErrorID		:= 100;
SIf.Cfg.uiByteOffset_rd_iErrorValue		:= 102;

SIf.Cfg.uiByteOffset_wr_iOff			:= 0;
SIf.Cfg.uiByteOffset_wr_iBeltOn			:= 2;
SIf.Cfg.uiByteOffset_wr_iManual			:= 4;
SIf.Cfg.uiByteOffset_wr_iRun			:= 6;
SIf.Cfg.uiByteOffset_wr_iSetParam		:= 8;
SIf.Cfg.uiByteOffset_wr_iGetParam		:= 10;
SIf.Cfg.uiByteOffset_wr_iAckError		:= 12;
SIf.Cfg.uiByteOffset_wr_adiTemp_mc		:= 30;
SIf.Cfg.uiByteOffset_wr_adiAir_p		:= 62;
SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min	:= 94;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CONNECTBusy" Id="{21ea10b9-d876-412b-a891-4fb2c3fb3e07}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CONNECTBusy'}
METHOD PROTECTED sta_CONNECTBusy : BOOL
VAR
	bBusy: BOOL;
	bError: BOOL;
	udiErrID: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		THIS^.fbOpen.stSettings.sHost			:= SIf.Cfg.tIpAddress; (* Remote (server) address. String containing an (Ipv4) Internet Protocol dotted address. *)
		THIS^.fbOpen.stSettings.nPort			:= SIf.Cfg.udiPortAdress; (* Remote (server) Internet Protocol (IP) port. *)
		THIS^.fbOpen.stSettings.eProtocol		:= eNLinkProtocol_MPI; (* Lan link protocol type *)
		THIS^.fbOpen.stSettings.eTransport		:= eNLinkTransport_TCPIP; (* Used transport protocol *)
		THIS^.fbOpen.tTimeout					:= SIf.Cfg.tTimeout; (* Maximum time allowed for the execution of the command *)
		
		IF NOT CIf.SwCfg.bolSimulation THEN
			// Open connection
			THIS^.fbOpen( hLink := hLink, bExecute := FALSE);
			THIS^.fbOpen( hLink := hLink, bExecute := TRUE);
		END_IF
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// check status of fbOpen
	THIS^.fbOpen( hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		bBusy := FALSE;
		bError := FALSE;
		udiErrID := 0;
	END_IF
	
	// State Change Condition
	IF NOT bBusy THEN
		Out_udiDriverErrorID := udiErrID;
		IF bError THEN
			Out_bDriverError := TRUE;
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
		ELSE
			Out_bDriverError := FALSE;
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_CONNECT;
		END_IF
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="bitAccess" Id="{258f5bd2-1efd-436d-9211-e24d2dd2a567}">
      <Declaration><![CDATA[{attribute 'object_name' := 'bitAccess'}
METHOD bitAccess : BOOL
VAR_INPUT
	in_byte: BYTE;
	in_bit: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE in_bit OF
	0: bitAccess := in_byte.0;
	1: bitAccess := in_byte.1;
	2: bitAccess := in_byte.2;
	3: bitAccess := in_byte.3;
	4: bitAccess := in_byte.4;
	5: bitAccess := in_byte.5;
	6: bitAccess := in_byte.6;
	7: bitAccess := in_byte.7;
ELSE
	bitAccess := in_byte.0;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_READBusy" Id="{2cb0706c-9fd7-431b-9abe-33bbdc307e7f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_READBusy'}
METHOD PROTECTED sta_READBusy : BOOL
VAR
	bBusy: BOOL;
	bError: BOOL;
	udiErrID: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF NOT CIf.SwCfg.bolSimulation THEN
			// Read data
			fbFetch(hLink := hLink, bExecute := FALSE );
			fbFetch(hLink := hLink, (* Communication link handle *)
					devAddr := SIf.Cfg.nDeviceAddress, (* Device address, MPI address of the remote component or its PROFIBUS address *)
					eArea:= eNLinkArea_DB, (* PLC data area *)
					nDB:= SIf.Cfg.nDatablockNumber, (* Data block number from which the data is read (DB, DX only). *)
					nOffset:= SIf.Cfg.nReadStartAddress, (* Start byte/word address from which the data are taken to *)
					cbBuffer:= SIZEOF(anReadBuffer), (* Contains the max. number of destination bytes to be received *)
					pBuffer:= ADR(anReadBuffer), (* Contains the address of the destination buffer for the received data *)
					bExecute:= TRUE); (* Rising edge at this input starts command execution *)
		END_IF
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// check status of fbFetch
	fbFetch(hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		bBusy := FALSE;
		bError := FALSE;
		udiErrID := 0;
	END_IF
	
	// State Change Condition
	IF NOT bBusy THEN
		Out_udiDriverErrorID := udiErrID;
		IF bError THEN
			Out_bDriverError := TRUE;
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
		ELSE
			Out_bDriverError := FALSE;
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_READ;
		END_IF
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_WRITEBusy" Id="{38c336c1-bf31-4e72-aeaa-edfcb54fee24}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_WRITEBusy'}
METHOD PROTECTED sta_WRITEBusy : BOOL
VAR
	uiIdx: UINT;
	bBusy: BOOL;
	bError: BOOL;
	udiErrID: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		me.SubStateMachine.intState := IBH_CmdState.cSTA_SUB_1;
		me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_1;
		
		// Prepare Write Buffer
		// !!!ATTENTION!!!
		// Motorola: Big-Endien: Most Significant Bits First (Siemens)
		// Intel: Little-Endien: Least Significant Bits First (Beckhoff)
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iOff		+0]	:= INT_TO_BYTE(SHR( THIS^.iOff,		1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iOff		+1]	:= INT_TO_BYTE(SHR( THIS^.iOff,		0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iBeltOn	+0]	:= INT_TO_BYTE(SHR( THIS^.iBeltOn,	1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iBeltOn	+1]	:= INT_TO_BYTE(SHR( THIS^.iBeltOn,	0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iManual	+0]	:= INT_TO_BYTE(SHR( THIS^.iManual,	1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iManual	+1]	:= INT_TO_BYTE(SHR( THIS^.iManual,	0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iRun		+0]	:= INT_TO_BYTE(SHR( THIS^.iRun,		1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iRun		+1]	:= INT_TO_BYTE(SHR( THIS^.iRun,		0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iSetParam	+0]	:= INT_TO_BYTE(SHR( THIS^.iSetParam,	1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iSetParam	+1]	:= INT_TO_BYTE(SHR( THIS^.iSetParam,	0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iGetParam	+0]	:= INT_TO_BYTE(SHR( THIS^.iGetParam,	1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iGetParam	+1]	:= INT_TO_BYTE(SHR( THIS^.iGetParam,	0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iAckError	+0]	:= INT_TO_BYTE(SHR( THIS^.iAckError,	1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iAckError	+1]	:= INT_TO_BYTE(SHR( THIS^.iAckError,	0*8));
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiTemp_mc+0 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiTemp_dc[uiIdx], 3*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiTemp_mc+1 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiTemp_dc[uiIdx], 2*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiTemp_mc+2 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiTemp_dc[uiIdx], 1*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiTemp_mc+3 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiTemp_dc[uiIdx], 0*8));
		END_FOR
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiAir_p+0 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiAir_p[uiIdx], 3*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiAir_p+1 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiAir_p[uiIdx], 2*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiAir_p+2 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiAir_p[uiIdx], 1*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiAir_p+3 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiAir_p[uiIdx], 0*8));
		END_FOR
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min+0] := DINT_TO_BYTE(SHR( THIS^.diSpeed_mm_min, 3*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min+1] := DINT_TO_BYTE(SHR( THIS^.diSpeed_mm_min, 2*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min+2] := DINT_TO_BYTE(SHR( THIS^.diSpeed_mm_min, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min+3] := DINT_TO_BYTE(SHR( THIS^.diSpeed_mm_min, 0*8));
		
		bRememberIncrementSetParam := bIncrementSetParam;
		bIncrementSetParam := FALSE;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		me.SubStateMachine.intState := IBH_CmdState.cSTA_SUB_5;
		me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_5;
	END_IF
		
	CASE me.SubStateMachine.intState OF
		
		// 1
		IBH_CmdState.cSTA_SUB_1:
			
			// Write data
			fbWrite(hLink := hLink, bExecute := FALSE );
			fbWrite(hLink := hLink,
					devAddr := SIf.Cfg.nDeviceAddress, (* Device address, MPI address of the remote component or its PROFIBUS address *)
					eArea:= eNLinkArea_DB, (* PLC data area *)
					nDB:= SIf.Cfg.nDatablockNumber, (* Data block number to which the data is written (DB, DX only) *)
					nOffset:= SIf.Cfg.nWriteStartAddress, (* Start byte/word address to which the data is send *)
					cbBuffer:= SIZEOF(anWriteBuffer), (* Contains the number of source bytes to be send *)
					pBuffer:= ADR(anWriteBuffer), (* Contains the address of the source buffer containing the data to be send *)
					bExecute:= TRUE); (* Rising edge at this input starts command execution *)
					
			me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_2;
			
		// Wait and send 
		IBH_CmdState.cSTA_SUB_2:
			// check status of fbWrite
			fbWrite(hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
			
			// State Change Condition
			IF NOT bBusy THEN
				Out_udiDriverErrorID := udiErrID;
				IF bError THEN
					Out_bDriverError := TRUE;
					me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
				ELSE
					Out_bDriverError := FALSE;
					IF bRememberIncrementSetParam THEN
						me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_3;
					ELSE
						me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_5;
					END_IF
				END_IF
			END_IF
			
		// 3
		IBH_CmdState.cSTA_SUB_3:
			bRememberIncrementSetParam := FALSE;
			IF (iSetParam = MAX_INT OR iSetParam < 0) THEN
				iSetParam := 0;
			END_IF
			iSetParam := iSetParam + 1;
		
			// Adapt Write Buffer
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iSetParam	+0]	:= INT_TO_BYTE(SHR( THIS^.iSetParam,	1*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iSetParam	+1]	:= INT_TO_BYTE(SHR( THIS^.iSetParam,	0*8));
			
			// Write data
			fbWrite(hLink := hLink, bExecute := FALSE );
			fbWrite(hLink := hLink,
					devAddr := SIf.Cfg.nDeviceAddress, (* Device address, MPI address of the remote component or its PROFIBUS address *)
					eArea:= eNLinkArea_DB, (* PLC data area *)
					nDB:= SIf.Cfg.nDatablockNumber, (* Data block number to which the data is written (DB, DX only) *)
					nOffset:= SIf.Cfg.nWriteStartAddress, (* Start byte/word address to which the data is send *)
					cbBuffer:= SIZEOF(anWriteBuffer), (* Contains the number of source bytes to be send *)
					pBuffer:= ADR(anWriteBuffer), (* Contains the address of the source buffer containing the data to be send *)
					bExecute:= TRUE); (* Rising edge at this input starts command execution *)
			
			me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_4;
			
		// 4
		IBH_CmdState.cSTA_SUB_4:
			
			// check status of fbWrite
			fbWrite(hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
			
			// State Change Condition
			IF NOT bBusy THEN
				Out_udiDriverErrorID := udiErrID;
				IF bError THEN
					Out_bDriverError := TRUE;
					me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
				ELSE
					Out_bDriverError := FALSE;
					me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_5;
				END_IF
			END_IF
			
		// 5
		IBH_CmdState.cSTA_SUB_5:
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_WRITE;
			
	END_CASE
		

// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_WRITE" Id="{38f8544c-c647-41db-be4c-f8d9cdd1890a}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_WRITE'}
METHOD PROTECTED sta_WRITE : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	CASE me.intCmd OF
		// OFF
		Base_PLC.cCMD_OFF:
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_READBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_DISCONNECT" Id="{3ee57a3d-048a-471e-8c35-53387a812277}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_DISCONNECT'}
METHOD PROTECTED sta_DISCONNECT : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	CASE me.intCmd OF
		// OFF
		Base_PLC.cCMD_OFF:
			me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_CONNECTBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Action Name="setAckError" Id="{44553939-dd9d-4573-96eb-714c3f62bf0d}">
      <Implementation>
        <ST><![CDATA[IF (iAckError = MAX_INT OR iAckError < 0) THEN
	iAckError := 0;
END_IF

iAckError := iAckError + 1;]]></ST>
      </Implementation>
    </Action>
    <Method Name="getCtrlSIf" Id="{5d62d1c6-ef1a-4acf-8a92-c1d071f8a399}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCtrlSIf'}
METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_IBH]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Action Name="setRun" Id="{65c28abc-872d-4974-ac52-14b618da33da}">
      <Implementation>
        <ST><![CDATA[IF (iRun = MAX_INT OR iRun < 0) THEN
	iRun := 0;
END_IF

iRun := iRun + 1;]]></ST>
      </Implementation>
    </Action>
    <Method Name="sta_READ" Id="{75bf96e5-4d01-4337-b000-089b7dd4522e}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_READ'}
METHOD PROTECTED sta_READ : BOOL
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// Analyse Read Buffer
	// !!!ATTENTION!!!
	// Motorola: Big-Endien: Most Significant Bits First (Siemens)
	// Intel: Little-Endien: Least Significant Bits First (Beckhoff)
	THIS^.Out_iStatus :=		SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iStatus+0]),1*8)
							+	SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iStatus+1]),0*8);
	THIS^.Out_bOff		:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bOff]		,SIf.Cfg.uiBitOffset_rd_bOff);
	THIS^.Out_bBeltOn	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bBeltOn]		,SIf.Cfg.uiBitOffset_rd_bBeltOn);
	THIS^.Out_bManual	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bManual]		,SIf.Cfg.uiBitOffset_rd_bManual);
	THIS^.Out_bRun		:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bRun]		,SIf.Cfg.uiBitOffset_rd_bRun);
	THIS^.Out_bSetParam	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bSetParam]	,SIf.Cfg.uiBitOffset_rd_bSetParam);
	THIS^.Out_bGetParam	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bGetParam]	,SIf.Cfg.uiBitOffset_rd_bGetParam);
	THIS^.Out_bAckError	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bAckError]	,SIf.Cfg.uiBitOffset_rd_bAckError);
	FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
		THIS^.Out_adiTemp_dc[uiIdx] :=		SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiTemp_mc+0 + uiIdx*4]),3*8)
										+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiTemp_mc+1 + uiIdx*4]),2*8)
										+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiTemp_mc+2 + uiIdx*4]),1*8)
										+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiTemp_mc+3 + uiIdx*4]),0*8);
	END_FOR
	FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
		THIS^.Out_adiAir_p[uiIdx] :=		SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiAir_p+0 + uiIdx*4]),3*8)
										+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiAir_p+1 + uiIdx*4]),2*8)
										+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiAir_p+2 + uiIdx*4]),1*8)
										+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiAir_p+3 + uiIdx*4]),0*8);
	END_FOR
	THIS^.Out_diSpeed_mm_min :=		SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min+0]),3*8)
								+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min+1]),2*8)
								+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min+2]),1*8)
								+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min+3]),0*8);
	THIS^.Out_iErrorLevel :=		SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iErrorLevel+0]),1*8)
								+	SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iErrorLevel+1]),0*8);
	THIS^.Out_iErrorID :=			SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iErrorID+0]),1*8)
								+	SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iErrorID+1]),0*8);
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		THIS^.Out_iStatus	:= 1;
		THIS^.Out_bOff		:= TRUE;
		THIS^.Out_bBeltOn	:= FALSE;
		THIS^.Out_bManual	:= FALSE;
		THIS^.Out_bRun		:= FALSE;
		THIS^.Out_bSetParam	:= FALSE;
		THIS^.Out_bGetParam	:= FALSE;
		THIS^.Out_bAckError	:= FALSE;
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
			THIS^.Out_adiTemp_dc[uiIdx] := 0;
		END_FOR
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
			THIS^.Out_adiAir_p[uiIdx] := 0;
		END_FOR
		THIS^.Out_diSpeed_mm_min :=	0;
		THIS^.Out_iErrorLevel := 0;
		THIS^.Out_iErrorID := 0;
	END_IF
	
	// State Change Condition
	CASE me.intCmd OF
		// OFF
		Base_PLC.cCMD_OFF:
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_WRITEBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PONBusy" Id="{81d2c900-5bf7-4d3b-87af-25331d6880a6}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PONBusy'}
METHOD PROTECTED sta_PONBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF

	// State Change Condition
	me.StateMachine.intStateNext := Base_PLC.cSTA_PON;


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{9c944823-43df-4c10-babf-48ea7dfe4b42}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFFBusy'}
METHOD PROTECTED sta_OFFBusy : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// Reset Output
	Out_bDriverError := FALSE;
	Out_udiDriverErrorID := 0;
	
	// State Change Condition
	me.StateMachine.intStateNext := Base_PLC.cCMD_OFF;


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{b6378721-e5d5-48a1-a704-766c361a5de7}">
      <Declaration><![CDATA[{attribute 'object_name' := 'StateMachine'}
METHOD PROTECTED StateMachine : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	// CONNECT
    IBH_CmdState.cSTA_CONNECT: 
        THIS^.sta_CONNECT();
    IBH_CmdState.cSTA_CONNECTBusy: 
        THIS^.sta_CONNECTBusy();
	// WRITE
	IBH_CmdState.cSTA_WRITE: 
        THIS^.sta_WRITE();
    IBH_CmdState.cSTA_WRITEBusy: 
        THIS^.sta_WRITEBusy();
	// READ
	IBH_CmdState.cSTA_READ: 
        THIS^.sta_READ();
    IBH_CmdState.cSTA_READBusy: 
        THIS^.sta_READBusy();
	// DISCONNECT
	IBH_CmdState.cSTA_DISCONNECT: 
        THIS^.sta_DISCONNECT();
    IBH_CmdState.cSTA_DISCONNECTBusy: 
        THIS^.sta_DISCONNECTBusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{c3d516d7-ca61-4e12-ab7d-eb014c048419}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCmdState'}
METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states

IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
		CASE intCmdState OF
			IBH_CmdState.cCMD_CONNECT:
				getCmdState := 'CONNECT';
			IBH_CmdState.cCMD_WRITE:
				getCmdState := 'WRITE';
			IBH_CmdState.cCMD_READ:
				getCmdState := 'READ';
			IBH_CmdState.cCMD_DISCONNECT:
				getCmdState := 'DISCONNECT';
		ELSE
			getCmdState := 'Cmd not defined';
		END_CASE;
	ELSE
		// state's
		CASE intCmdState OF
			// CONNECT
			IBH_CmdState.cSTA_CONNECTBusy: 
				getCmdState := 'CONNECTBusy';
			IBH_CmdState.cSTA_CONNECT: 
				getCmdState := 'CONNECT';
			// WRITE
			IBH_CmdState.cSTA_WRITEBusy: 
				getCmdState := 'WRITEBusy';
			IBH_CmdState.cSTA_WRITE: 
				getCmdState := 'WRITE';
			// READ
			IBH_CmdState.cSTA_READBusy: 
				getCmdState := 'READBusy';
			IBH_CmdState.cSTA_READ: 
				getCmdState := 'READ';
			// DISCONNECT
			IBH_CmdState.cSTA_DISCONNECTBusy: 
				getCmdState := 'DISCONNECTBusy';
			IBH_CmdState.cSTA_DISCONNECT: 
				getCmdState := 'DISCONNECT';
		ELSE
			getCmdState := 'State not defined';
		END_CASE
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="setAirflow" Id="{cc113977-e485-4cd4-a01e-b812359ebd45}">
      <Declaration><![CDATA[{attribute 'object_name' := 'setAirflow'}
METHOD setAirflow
VAR_INPUT
	/// Airflow in % 
	In_adiAir_p: ARRAY[1..MAX_NUMBER_OF_OVEN_MODULES] OF DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[adiAir_p := In_adiAir_p;
bIncrementSetParam := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{ce678287-d0c0-4c11-aa96-f26232737c22}">
      <Declaration><![CDATA[{attribute 'object_name' := 'Always'}
METHOD PROTECTED Always : BOOL
VAR
	fbOVN: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	; // always error supervision
	// ---------------------------------------------------------------------------------
END_IF

// ----------------------------------------------------------------------------------
// Conditions Always
IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	me.StateMachine.intStateNext := cSTA_OFFBusy;
	me.bolChangeBackToAUTO := FALSE;
END_IF

IF (CIf.SwCfg.bolExist=FALSE) THEN // hardware of controller does not exist
	me.StateMachine.intStateNext := cSTA_SINGLE_ANSWER;
ELSE
	IF (((me.StateMachine.intState=cSTA_INITIALIZED) OR (me.intCmd=cCMD_PON)) 
		AND (me.StateMachine.intState<>cSTA_PONBusy) AND (me.StateMachine.intState<>cSTA_PON)
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)) THEN // switch after startup to PONBusy
		me.StateMachine.intStateNext := cSTA_PONBusy;
		
	ELSIF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.intCmd=cCMD_EOFF)) 
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)
		AND (me.StateMachine.intState>cSTA_PON)) THEN
		me.StateMachine.intStateNext := cSTA_EOFFBusy;
	
	ELSIF (((me.Alarm.eActivAlmClass=E_AlmClass.OFF) (*OR (me.intCmd=cCMD_OFF)*))
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit)
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)
		AND (me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)
		AND (me.StateMachine.intState>cSTA_PON)) THEN
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	
	END_IF
END_IF

//SUPER^.Always();	// TODO: remove code above and use this line, but deactivate automatic OFF on cCMD_OFF

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState <> cSTA_SINGLE_ANSWER) THEN
	
	IF		NOT CIf.SwCfg.bolEnable
		AND (me.StateMachine.intState<>cSTA_OFF)
		AND (me.StateMachine.intState<>cSTA_OFFBusy) THEN
		CIf.Job.intACmd := cCMD_OFF;
	END_IF
	
	Out_bDriverConnected := FALSE;
	IF		(me.StateMachine.intState=cSTA_WRITE) OR (me.StateMachine.intState=cSTA_WRITEBusy)
		OR	(me.StateMachine.intState=cSTA_READ) OR (me.StateMachine.intState=cSTA_READBusy) THEN
		Out_bDriverConnected := TRUE;
	END_IF
	
END_IF

// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState = cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Action Name="setOff" Id="{cf6019e3-6f56-4571-9556-7b2c8be4ce3a}">
      <Implementation>
        <ST><![CDATA[IF (iOff = MAX_INT OR ioff < 0) THEN
	iOff := 0;
END_IF

iOff := iOff + 1;]]></ST>
      </Implementation>
    </Action>
    <Method Name="setSpeed" Id="{e1ee721f-99f7-487d-be02-76937e33dab0}">
      <Declaration><![CDATA[{attribute 'object_name' := 'setSpeed'}
METHOD setSpeed
VAR_INPUT
	/// Belt speed in mm/min 
	In_diSpeed_mm_min: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[diSpeed_mm_min := In_diSpeed_mm_min;
bIncrementSetParam := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Action Name="setBeltOn" Id="{eb96f45a-ccbb-4b9d-b34a-02806c599568}">
      <Implementation>
        <ST><![CDATA[IF (iBeltOn = MAX_INT OR iBeltOn < 0) THEN
	iBeltOn := 0;
END_IF

iBeltOn := iBeltOn + 1;]]></ST>
      </Implementation>
    </Action>
    <Method Name="sta_CONNECT" Id="{ee8c16a5-8b81-47d9-b812-1c3e8e6f51a5}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CONNECT'}
METHOD PROTECTED sta_CONNECT : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	CASE me.intCmd OF
		// OFF
		Base_PLC.cCMD_OFF:
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_WRITEBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Action Name="setStandby" Id="{ef93d172-8b44-42a4-9172-7b1faf91f740}">
      <Implementation>
        <ST><![CDATA[IF (iManual = MAX_INT OR iManual < 0) THEN
	iManual := 0;
END_IF

iManual := iManual + 1;]]></ST>
      </Implementation>
    </Action>
    <Method Name="sta_DISCONNECTBusy" Id="{f12d780c-aad8-4f99-8cd6-b3f5cc2ebfc1}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_DISCONNECTBusy'}
METHOD PROTECTED sta_DISCONNECTBusy : BOOL
VAR
	bBusy: BOOL;
	bError: BOOL;
	udiErrID: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF NOT CIf.SwCfg.bolSimulation THEN
			// Close connection
			fbClose(hLink := hLink, bExecute := FALSE);
			fbClose(hLink := hLink, bExecute := TRUE);
		END_IF
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// check status of fbClose
	fbClose(hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		bBusy := FALSE;
		bError := FALSE;
		udiErrID := 0;
	END_IF
	
	// State Change Condition
	IF NOT bBusy THEN
		Out_udiDriverErrorID := udiErrID;
		IF bError THEN
			Out_bDriverError := TRUE;
		ELSE
			Out_bDriverError := FALSE;
		END_IF
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECT;
	END_IF

// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>