<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4019.2">
  <POU Name="FB_IBH" Id="{b0e34786-1945-4fbf-ba31-18ca8b1b1f1d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_IBH EXTENDS FB_CtrlBase
VAR_OUTPUT
	/// Status 
	Out_iStatus: INT;
	/// Machine off 
	Out_bOff: BOOL;
	/// Band on 
	Out_bBeltOn: BOOL;
	/// Manual Mode 
	Out_bManual: BOOL;
	/// Standart drying process 
	Out_bRun: BOOL;
	/// Set Parameter 
	Out_bSetParam: BOOL;
	/// Get Parameter 
	Out_bGetParam: BOOL;
	/// Resetting error 
	Out_bAckError: BOOL;
	/// Actual temperature in deci °C 
	Out_adiTemp_dc: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Aactual airflow in % 
	Out_adiAir_p: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Actual belt speed in mm/min 
	Out_diSpeed_mm_min: DINT;
	/// 1=Information, 2=Warning, 3=Error 
	Out_iErrorLevel: INT;
	/// Error ID (e.g. 100=temperature overflow) 
	Out_iErrorID: INT;
	Out_bDriverConnected: BOOL;
	Out_bDriverError: BOOL;
	Out_udiDriverErrorID: UDINT;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_IBH;
	/// Latest Command
	intLatestCmd: INT;
	/// Temperature in deci °C 
	adiTemp_dc: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Airflow in % 
	adiAir_p: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Belt speed in mm/min 
	diSpeed_mm_min: DINT;
	/// Try to reset error 
	bolAckError: BOOL;
	bSetParam: BOOL;
	bRememberSetParam: BOOL;
	fbOpen: Tc2_S5S7Com.FB_NLinkOpen;
	fbWrite: Tc2_S5S7Com.FB_NLinkWrite;
	fbFetch: Tc2_S5S7Com.FB_NLinkFetch;
	fbClose: Tc2_S5S7Com.FB_NLinkClose;
	/// Communication link handle 
	hLink: T_HNLINK;
	/// read data buffer 
	anReadBuffer: ARRAY[0..(READ_BUFFER_LENGTH - 1)] OF BYTE;
	/// data to write 
	anWriteBuffer: ARRAY[0..(WRITE_BUFFER_LENGTH - 1)] OF BYTE;
	
	// simulation
	iSimStatus: INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Copyright 2017 Cimpress

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. *)

(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
IBH Link Connection Implementation

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		09.01.2014		BB			Start history
___________________________________________________________________________________________________*)

SUPER^();]]></ST>
    </Implementation>
    <Method Name="sta_OFF" Id="{079a83bc-f368-473d-9a58-2d5eacbc7942}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFF'}
METHOD PROTECTED sta_OFF : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	IF CIf.SwCfg.bolEnable THEN
		CASE me.intCmd OF
			// CONNECT
			IBH_CmdState.cCMD_CONNECT, IBH_CmdState.cCMD_WRITE, IBH_CmdState.cCMD_READ:
				me.StateMachine.intStateNext := IBH_CmdState.cSTA_CONNECTBusy;
		ELSE
			// DEFAULT
			;
		END_CASE
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{08684d9c-e6b9-47e2-aa66-b28ab5b7c8a7}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PON'}
METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
	

// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{0accaec6-7a10-4d05-90a8-2093259b81bc}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CtrlInit'}
METHOD CtrlInit : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// add childs
// ...]]></ST>
      </Implementation>
    </Method>
    <Method Name="setTemp" Id="{12b4e731-abaa-42a5-a1ec-d738ad8ef065}">
      <Declaration><![CDATA[{attribute 'object_name' := 'setTemp'}
METHOD setTemp
VAR_INPUT
	/// Temperature in deci °C 
	In_adiTemp_dc: ARRAY[1..MAX_NUMBER_OF_OVEN_MODULES] OF DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[adiTemp_dc := In_adiTemp_dc;
bSetParam := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{1e98861f-0bc6-4fd1-8c68-a6e91c74e1a0}">
      <Declaration><![CDATA[{attribute 'object_name' := 'FB_init'}
METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR uiIdx:=0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[uiIdx].intCmd=cSTA_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

// Add configuration of own comands
CIf.Job.aCmdList[uiIdx].intCmd := IBH_CmdState.cCMD_CONNECT;
CIf.Job.aCmdList[uiIdx].strName := 'CONNECT';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;
uiIdx := uiIdx+1;
CIf.Job.aCmdList[uiIdx].intCmd := IBH_CmdState.cCMD_WRITE;
CIf.Job.aCmdList[uiIdx].strName := 'WRITE';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;
uiIdx := uiIdx+1;
CIf.Job.aCmdList[uiIdx].intCmd := IBH_CmdState.cCMD_READ;
CIf.Job.aCmdList[uiIdx].strName := 'READ';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;
uiIdx := uiIdx+1;
CIf.Job.aCmdList[uiIdx].intCmd := IBH_CmdState.cCMD_DISCONNECT;
CIf.Job.aCmdList[uiIdx].strName := 'DISCONNECT';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_IBH';
CIf.Info.strFullName := 'IBH Link';

//*******************************************************************************
// initial values
//*******************************************************************************

// Software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolEnable := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// Internal Variables (Input)
intLatestCmd := 0;
FOR uiIdx:=0 TO MAX_NUMBER_OF_OVEN_MODULES-1 BY 1 DO
	adiTemp_dc[uiIdx] := 0;
	adiAir_p[uiIdx] := 0;
END_FOR
diSpeed_mm_min := 0;
bolAckError := FALSE;
bSetParam := FALSE;
bRememberSetParam := FALSE;

// simulation
iSimStatus := 1;

// Configuration
SIf.Cfg.tIpAddress						:= '192.168.0.50';
SIf.Cfg.udiPortAdress					:= 1099;
SIf.Cfg.nDeviceAddress					:= 2;
SIf.Cfg.nDatablockNumber				:= 22;
SIf.Cfg.tTimeout						:= T#15S;

SIf.Cfg.nWriteStartAddress				:= 0;
SIf.Cfg.nReadStartAddress				:= 110;

SIf.Cfg.uiByteOffset_rd_iStatus			:= 0;
SIf.Cfg.uiByteOffset_rd_bOff			:= 10;
SIf.Cfg.uiBitOffset_rd_bOff				:= 0;
SIf.Cfg.uiByteOffset_rd_bBeltOnly		:= 10;
SIf.Cfg.uiBitOffset_rd_bBeltOnly		:= 1;
SIf.Cfg.uiByteOffset_rd_bManual			:= 10;
SIf.Cfg.uiBitOffset_rd_bManual			:= 2;
SIf.Cfg.uiByteOffset_rd_bRun			:= 10;
SIf.Cfg.uiBitOffset_rd_bRun				:= 3;
SIf.Cfg.uiByteOffset_rd_bSetParam		:= 10;
SIf.Cfg.uiBitOffset_rd_bSetParam		:= 4;
SIf.Cfg.uiByteOffset_rd_bGetParam		:= 10;
SIf.Cfg.uiBitOffset_rd_bGetParam		:= 5;
SIf.Cfg.uiByteOffset_rd_bAckError		:= 10;
SIf.Cfg.uiBitOffset_rd_bAckError		:= 6;
SIf.Cfg.uiByteOffset_rd_adiTemp_mc		:= 30;
SIf.Cfg.uiByteOffset_rd_adiAir_p		:= 62;
SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min	:= 94;
SIf.Cfg.uiByteOffset_rd_iErrorLevel		:= 98;
SIf.Cfg.uiByteOffset_rd_iErrorID		:= 100;
SIf.Cfg.uiByteOffset_rd_iErrorValue		:= 102;

SIf.Cfg.uiByteOffset_wr_iOff			:= 0;
SIf.Cfg.uiByteOffset_wr_iBeltOnly		:= 2;
SIf.Cfg.uiByteOffset_wr_iManual			:= 4;
SIf.Cfg.uiByteOffset_wr_iRun			:= 6;
SIf.Cfg.uiByteOffset_wr_iSetParam		:= 8;
SIf.Cfg.uiByteOffset_wr_iGetParam		:= 10;
SIf.Cfg.uiByteOffset_wr_iAckError		:= 12;
SIf.Cfg.uiByteOffset_wr_adiTemp_mc		:= 30;
SIf.Cfg.uiByteOffset_wr_adiAir_p		:= 62;
SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min	:= 94;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CONNECTBusy" Id="{21ea10b9-d876-412b-a891-4fb2c3fb3e07}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CONNECTBusy'}
METHOD PROTECTED sta_CONNECTBusy : BOOL
VAR
	bBusy: BOOL;
	bError: BOOL;
	udiErrID: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		THIS^.fbOpen.stSettings.sHost			:= SIf.Cfg.tIpAddress; (* Remote (server) address. String containing an (Ipv4) Internet Protocol dotted address. *)
		THIS^.fbOpen.stSettings.nPort			:= SIf.Cfg.udiPortAdress; (* Remote (server) Internet Protocol (IP) port. *)
		THIS^.fbOpen.stSettings.eProtocol		:= eNLinkProtocol_MPI; (* Lan link protocol type *)
		THIS^.fbOpen.stSettings.eTransport		:= eNLinkTransport_TCPIP; (* Used transport protocol *)
		THIS^.fbOpen.tTimeout					:= SIf.Cfg.tTimeout; (* Maximum time allowed for the execution of the command *)
		
		IF NOT CIf.SwCfg.bolSimulation THEN
			// Open connection
			THIS^.fbOpen( hLink := hLink, bExecute := FALSE);
			THIS^.fbOpen( hLink := hLink, bExecute := TRUE);
		END_IF
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// check status of fbOpen
	THIS^.fbOpen( hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		bBusy := FALSE;
		bError := FALSE;
		udiErrID := 0;
	END_IF
	
	// State Change Condition
	IF NOT bBusy THEN
		Out_udiDriverErrorID := udiErrID;
		IF bError THEN
			Out_bDriverError := TRUE;
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
		ELSE
			Out_bDriverError := FALSE;
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_CONNECT;
		END_IF
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="bitAccess" Id="{258f5bd2-1efd-436d-9211-e24d2dd2a567}">
      <Declaration><![CDATA[{attribute 'object_name' := 'bitAccess'}
METHOD bitAccess : BOOL
VAR_INPUT
	in_byte: BYTE;
	in_bit: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE in_bit OF
	0: bitAccess := in_byte.0;
	1: bitAccess := in_byte.1;
	2: bitAccess := in_byte.2;
	3: bitAccess := in_byte.3;
	4: bitAccess := in_byte.4;
	5: bitAccess := in_byte.5;
	6: bitAccess := in_byte.6;
	7: bitAccess := in_byte.7;
ELSE
	bitAccess := in_byte.0;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_READBusy" Id="{2cb0706c-9fd7-431b-9abe-33bbdc307e7f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_READBusy'}
METHOD PROTECTED sta_READBusy : BOOL
VAR
	bBusy: BOOL;
	bError: BOOL;
	udiErrID: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF NOT CIf.SwCfg.bolSimulation THEN
			// Read data
			fbFetch(hLink := hLink, bExecute := FALSE );
			fbFetch(hLink := hLink, (* Communication link handle *)
					devAddr := SIf.Cfg.nDeviceAddress, (* Device address, MPI address of the remote component or its PROFIBUS address *)
					eArea:= eNLinkArea_DB, (* PLC data area *)
					nDB:= SIf.Cfg.nDatablockNumber, (* Data block number from which the data is read (DB, DX only). *)
					nOffset:= SIf.Cfg.nReadStartAddress, (* Start byte/word address from which the data are taken to *)
					cbBuffer:= SIZEOF(anReadBuffer), (* Contains the max. number of destination bytes to be received *)
					pBuffer:= ADR(anReadBuffer), (* Contains the address of the destination buffer for the received data *)
					bExecute:= TRUE); (* Rising edge at this input starts command execution *)
		END_IF
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// check status of fbFetch
	fbFetch(hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		bBusy := FALSE;
		bError := FALSE;
		udiErrID := 0;
	END_IF
	
	// State Change Condition
	IF NOT bBusy THEN
		Out_udiDriverErrorID := udiErrID;
		IF bError THEN
			Out_bDriverError := TRUE;
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
		ELSE
			Out_bDriverError := FALSE;
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_READ;
		END_IF
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_WRITEBusy" Id="{38c336c1-bf31-4e72-aeaa-edfcb54fee24}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_WRITEBusy'}
METHOD PROTECTED sta_WRITEBusy : BOOL
VAR
	uiIdx: UINT;
	bBusy: BOOL;
	bError: BOOL;
	udiErrID: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		me.SubStateMachine.intState := IBH_CmdState.cSTA_SUB_1;
		me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_1;
		
		// Prepare Write Buffer
		// !!!ATTENTION!!!
		// Motorola: Big-Endien: Most Significant Bits First (Siemens)
		// Intel: Little-Endien: Least Significant Bits First (Beckhoff)
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iOff		+0]	:= INT_TO_BYTE(SHR(0, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iOff		+1]	:= INT_TO_BYTE(SHR(0, 0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iBeltOnly	+0]	:= INT_TO_BYTE(SHR(0, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iBeltOnly	+1]	:= INT_TO_BYTE(SHR(0, 0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iManual	+0]	:= INT_TO_BYTE(SHR(0, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iManual	+1]	:= INT_TO_BYTE(SHR(0, 0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iRun		+0]	:= INT_TO_BYTE(SHR(0, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iRun		+1]	:= INT_TO_BYTE(SHR(0, 0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iSetParam	+0]	:= INT_TO_BYTE(SHR(0, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iSetParam	+1]	:= INT_TO_BYTE(SHR(0, 0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iGetParam	+0]	:= INT_TO_BYTE(SHR(0, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iGetParam	+1]	:= INT_TO_BYTE(SHR(0, 0*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iAckError	+0]	:= INT_TO_BYTE(SHR(0, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iAckError	+1]	:= INT_TO_BYTE(SHR(0, 0*8));
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules-1 BY 1 DO
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiTemp_mc+0 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiTemp_dc[uiIdx], 3*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiTemp_mc+1 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiTemp_dc[uiIdx], 2*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiTemp_mc+2 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiTemp_dc[uiIdx], 1*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiTemp_mc+3 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiTemp_dc[uiIdx], 0*8));
		END_FOR
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules-1 BY 1 DO
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiAir_p+0 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiAir_p[uiIdx], 3*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiAir_p+1 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiAir_p[uiIdx], 2*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiAir_p+2 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiAir_p[uiIdx], 1*8));
			anWriteBuffer[SIf.Cfg.uiByteOffset_wr_adiAir_p+3 + uiIdx*4] := DINT_TO_BYTE(SHR( THIS^.adiAir_p[uiIdx], 0*8));
		END_FOR
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min+0] := DINT_TO_BYTE(SHR( THIS^.diSpeed_mm_min, 3*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min+1] := DINT_TO_BYTE(SHR( THIS^.diSpeed_mm_min, 2*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min+2] := DINT_TO_BYTE(SHR( THIS^.diSpeed_mm_min, 1*8));
		anWriteBuffer[SIf.Cfg.uiByteOffset_wr_diSpeed_mm_min+3] := DINT_TO_BYTE(SHR( THIS^.diSpeed_mm_min, 0*8));
		
		bRememberSetParam := bSetParam;
		bSetParam := FALSE;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		me.SubStateMachine.intState := IBH_CmdState.cSTA_SUB_5;
		me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_5;
	END_IF
		
	CASE me.SubStateMachine.intState OF
		
		// 1: Write
		IBH_CmdState.cSTA_SUB_1:
			
			// Write data
			fbWrite(hLink := hLink, bExecute := FALSE );
			fbWrite(hLink := hLink,
					devAddr := SIf.Cfg.nDeviceAddress, (* Device address, MPI address of the remote component or its PROFIBUS address *)
					eArea:= eNLinkArea_DB, (* PLC data area *)
					nDB:= SIf.Cfg.nDatablockNumber, (* Data block number to which the data is written (DB, DX only) *)
					nOffset:= SIf.Cfg.nWriteStartAddress, (* Start byte/word address to which the data is send *)
					cbBuffer:= SIZEOF(anWriteBuffer), (* Contains the number of source bytes to be send *)
					pBuffer:= ADR(anWriteBuffer), (* Contains the address of the source buffer containing the data to be send *)
					bExecute:= TRUE); (* Rising edge at this input starts command execution *)
					
			me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_2;
			
		// 2: Wait
		IBH_CmdState.cSTA_SUB_2:
			// check status of fbWrite
			fbWrite(hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
			
			// State Change Condition
			IF NOT bBusy THEN
				Out_udiDriverErrorID := udiErrID;
				IF bError THEN
					Out_bDriverError := TRUE;
					me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
				ELSE
					Out_bDriverError := FALSE;
					me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_3;
				END_IF
			END_IF
			
		// 3: Adapt Buffer and Write
		IBH_CmdState.cSTA_SUB_3:
			
			// Adapt Write Buffer
			CASE intLatestCmd OF
				1: // Off
					anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iOff		+0]	:= INT_TO_BYTE(SHR(1, 1*8));
					anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iOff		+1]	:= INT_TO_BYTE(SHR(1, 0*8));
				2: // BeltOnly
					anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iBeltOnly	+0]	:= INT_TO_BYTE(SHR(1, 1*8));
					anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iBeltOnly	+1]	:= INT_TO_BYTE(SHR(1, 0*8));
				3: // Manual
					anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iManual	+0]	:= INT_TO_BYTE(SHR(1, 1*8));
					anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iManual	+1]	:= INT_TO_BYTE(SHR(1, 0*8));
				4: // Run
					anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iRun		+0]	:= INT_TO_BYTE(SHR(1, 1*8));
					anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iRun		+1]	:= INT_TO_BYTE(SHR(1, 0*8));
			END_CASE
			intLatestCmd := 0;
			
			IF (bRememberSetParam) THEN
				bRememberSetParam := FALSE;
				anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iSetParam	+0]	:= INT_TO_BYTE(SHR(1, 1*8));
				anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iSetParam	+1]	:= INT_TO_BYTE(SHR(1, 0*8));
			END_IF

			IF (bolAckError) THEN
				bolAckError := FALSE;
				anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iAckError	+0]	:= INT_TO_BYTE(SHR(1, 1*8));
				anWriteBuffer[SIf.Cfg.uiByteOffset_wr_iAckError	+1]	:= INT_TO_BYTE(SHR(1, 0*8));
			END_IF
			
			// Write data
			fbWrite(hLink := hLink, bExecute := FALSE );
			fbWrite(hLink := hLink,
					devAddr := SIf.Cfg.nDeviceAddress, (* Device address, MPI address of the remote component or its PROFIBUS address *)
					eArea:= eNLinkArea_DB, (* PLC data area *)
					nDB:= SIf.Cfg.nDatablockNumber, (* Data block number to which the data is written (DB, DX only) *)
					nOffset:= SIf.Cfg.nWriteStartAddress, (* Start byte/word address to which the data is send *)
					cbBuffer:= SIZEOF(anWriteBuffer), (* Contains the number of source bytes to be send *)
					pBuffer:= ADR(anWriteBuffer), (* Contains the address of the source buffer containing the data to be send *)
					bExecute:= TRUE); (* Rising edge at this input starts command execution *)
			
			me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_4;
			
		// 4: Wait
		IBH_CmdState.cSTA_SUB_4:
			
			// check status of fbWrite
			fbWrite(hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
			
			// State Change Condition
			IF NOT bBusy THEN
				Out_udiDriverErrorID := udiErrID;
				IF bError THEN
					Out_bDriverError := TRUE;
					me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
				ELSE
					Out_bDriverError := FALSE;
					me.SubStateMachine.intStateNext := IBH_CmdState.cSTA_SUB_5;
				END_IF
			END_IF
			
		// 5: Done
		IBH_CmdState.cSTA_SUB_5:
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_WRITE;
			
	END_CASE
		

// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_WRITE" Id="{38f8544c-c647-41db-be4c-f8d9cdd1890a}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_WRITE'}
METHOD PROTECTED sta_WRITE : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	CASE me.intCmd OF
		// OFF
		Base_PLC.cCMD_OFF:
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_READBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_DISCONNECT" Id="{3ee57a3d-048a-471e-8c35-53387a812277}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_DISCONNECT'}
METHOD PROTECTED sta_DISCONNECT : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	CASE me.intCmd OF
		// OFF
		Base_PLC.cCMD_OFF:
			me.StateMachine.intStateNext := BASE_PLC.cSTA_OFFBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_CONNECTBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Action Name="setAckError" Id="{44553939-dd9d-4573-96eb-714c3f62bf0d}">
      <Implementation>
        <ST><![CDATA[bolAckError := true;]]></ST>
      </Implementation>
    </Action>
    <Method Name="getCtrlSIf" Id="{5d62d1c6-ef1a-4acf-8a92-c1d071f8a399}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCtrlSIf'}
METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_IBH]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Action Name="setCmdRun" Id="{65c28abc-872d-4974-ac52-14b618da33da}">
      <Implementation>
        <ST><![CDATA[intLatestCmd := 4;

// simulation
iSimStatus := 4;]]></ST>
      </Implementation>
    </Action>
    <Method Name="sta_READ" Id="{75bf96e5-4d01-4337-b000-089b7dd4522e}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_READ'}
METHOD PROTECTED sta_READ : BOOL
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		THIS^.Out_iStatus	:= iSimStatus;
		THIS^.Out_bOff		:= (iSimStatus = 1);
		THIS^.Out_bBeltOn	:= (iSimStatus = 2);
		THIS^.Out_bManual	:= (iSimStatus = 3);
		THIS^.Out_bRun		:= (iSimStatus = 4);
		THIS^.Out_bSetParam	:= FALSE;
		THIS^.Out_bGetParam	:= FALSE;
		THIS^.Out_bAckError	:= FALSE;
		
		IF (iSimStatus = 4) THEN
			Out_adiTemp_dc := adiTemp_dc;
			Out_adiAir_p := adiAir_p;
		ELSE
			FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
				THIS^.Out_adiTemp_dc[uiIdx] := 0;
				THIS^.Out_adiAir_p[uiIdx] := 0;
			END_FOR
		END_IF
		
		IF (iSimStatus = 4) OR (iSimStatus = 2) THEN
			Out_diSpeed_mm_min := diSpeed_mm_min;
		ELSE
			THIS^.Out_diSpeed_mm_min :=	0;
		END_IF
		
		THIS^.Out_iErrorLevel := 0;
		THIS^.Out_iErrorID := 0;
	ELSE
		// Analyse Read Buffer
		// !!!ATTENTION!!!
		// Motorola: Big-Endien: Most Significant Bits First (Siemens)
		// Intel: Little-Endien: Least Significant Bits First (Beckhoff)
		THIS^.Out_iStatus :=		SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iStatus+0]),1*8)
								+	SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iStatus+1]),0*8);
		THIS^.Out_bOff		:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bOff]		,SIf.Cfg.uiBitOffset_rd_bOff);
		THIS^.Out_bBeltOn	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bBeltOnly]		,SIf.Cfg.uiBitOffset_rd_bBeltOnly);
		THIS^.Out_bManual	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bManual]		,SIf.Cfg.uiBitOffset_rd_bManual);
		THIS^.Out_bRun		:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bRun]		,SIf.Cfg.uiBitOffset_rd_bRun);
		THIS^.Out_bSetParam	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bSetParam]	,SIf.Cfg.uiBitOffset_rd_bSetParam);
		THIS^.Out_bGetParam	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bGetParam]	,SIf.Cfg.uiBitOffset_rd_bGetParam);
		THIS^.Out_bAckError	:= bitAccess( anReadBuffer[SIf.Cfg.uiByteOffset_rd_bAckError]	,SIf.Cfg.uiBitOffset_rd_bAckError);
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
			THIS^.Out_adiTemp_dc[uiIdx] :=		SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiTemp_mc+0 + uiIdx*4]),3*8)
											+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiTemp_mc+1 + uiIdx*4]),2*8)
											+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiTemp_mc+2 + uiIdx*4]),1*8)
											+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiTemp_mc+3 + uiIdx*4]),0*8);
		END_FOR
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules BY 1 DO
			THIS^.Out_adiAir_p[uiIdx] :=		SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiAir_p+0 + uiIdx*4]),3*8)
											+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiAir_p+1 + uiIdx*4]),2*8)
											+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiAir_p+2 + uiIdx*4]),1*8)
											+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_adiAir_p+3 + uiIdx*4]),0*8);
		END_FOR
		THIS^.Out_diSpeed_mm_min :=		SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min+0]),3*8)
									+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min+1]),2*8)
									+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min+2]),1*8)
									+	SHL(BYTE_TO_DINT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_diSpeed_mm_min+3]),0*8);
		THIS^.Out_iErrorLevel :=		SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iErrorLevel+0]),1*8)
									+	SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iErrorLevel+1]),0*8);
		THIS^.Out_iErrorID :=			SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iErrorID+0]),1*8)
									+	SHL(BYTE_TO_INT(anReadBuffer[SIf.Cfg.uiByteOffset_rd_iErrorID+1]),0*8);
	END_IF
									
	// State Change Condition
	CASE me.intCmd OF
		// OFF
		Base_PLC.cCMD_OFF:
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_WRITEBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PONBusy" Id="{81d2c900-5bf7-4d3b-87af-25331d6880a6}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PONBusy'}
METHOD PROTECTED sta_PONBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF

	// State Change Condition
	me.StateMachine.intStateNext := Base_PLC.cSTA_PON;


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{9c944823-43df-4c10-babf-48ea7dfe4b42}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFFBusy'}
METHOD PROTECTED sta_OFFBusy : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// Reset Output
	Out_bDriverError := FALSE;
	Out_udiDriverErrorID := 0;
	
	// State Change Condition
	me.StateMachine.intStateNext := Base_PLC.cCMD_OFF;


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="CtrlSIf" Id="{ac1b81dd-4af3-4d7b-b0e2-b818e149d37c}">
      <Declaration><![CDATA[PROPERTY PUBLIC CtrlSIf : POINTER TO T_Ctrl_SIf_IBH]]></Declaration>
      <Get Name="Get" Id="{db198881-bdc5-463a-9883-afe4a9ed0fa8}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[CtrlSIf := ADR(SIf);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="StateMachine" Id="{b6378721-e5d5-48a1-a704-766c361a5de7}">
      <Declaration><![CDATA[{attribute 'object_name' := 'StateMachine'}
METHOD PROTECTED StateMachine : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	// CONNECT
    IBH_CmdState.cSTA_CONNECT: 
        THIS^.sta_CONNECT();
    IBH_CmdState.cSTA_CONNECTBusy: 
        THIS^.sta_CONNECTBusy();
	// WRITE
	IBH_CmdState.cSTA_WRITE: 
        THIS^.sta_WRITE();
    IBH_CmdState.cSTA_WRITEBusy: 
        THIS^.sta_WRITEBusy();
	// READ
	IBH_CmdState.cSTA_READ: 
        THIS^.sta_READ();
    IBH_CmdState.cSTA_READBusy: 
        THIS^.sta_READBusy();
	// DISCONNECT
	IBH_CmdState.cSTA_DISCONNECT: 
        THIS^.sta_DISCONNECT();
    IBH_CmdState.cSTA_DISCONNECTBusy: 
        THIS^.sta_DISCONNECTBusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{c3d516d7-ca61-4e12-ab7d-eb014c048419}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCmdState'}
METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states

IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
		CASE intCmdState OF
			IBH_CmdState.cCMD_CONNECT:
				getCmdState := 'CONNECT';
			IBH_CmdState.cCMD_WRITE:
				getCmdState := 'WRITE';
			IBH_CmdState.cCMD_READ:
				getCmdState := 'READ';
			IBH_CmdState.cCMD_DISCONNECT:
				getCmdState := 'DISCONNECT';
		ELSE
			getCmdState := 'Cmd not defined';
		END_CASE;
	ELSE
		// state's
		CASE intCmdState OF
			// CONNECT
			IBH_CmdState.cSTA_CONNECTBusy: 
				getCmdState := 'CONNECTBusy';
			IBH_CmdState.cSTA_CONNECT: 
				getCmdState := 'CONNECT';
			// WRITE
			IBH_CmdState.cSTA_WRITEBusy: 
				getCmdState := 'WRITEBusy';
			IBH_CmdState.cSTA_WRITE: 
				getCmdState := 'WRITE';
			// READ
			IBH_CmdState.cSTA_READBusy: 
				getCmdState := 'READBusy';
			IBH_CmdState.cSTA_READ: 
				getCmdState := 'READ';
			// DISCONNECT
			IBH_CmdState.cSTA_DISCONNECTBusy: 
				getCmdState := 'DISCONNECTBusy';
			IBH_CmdState.cSTA_DISCONNECT: 
				getCmdState := 'DISCONNECT';
		ELSE
			getCmdState := 'State not defined';
		END_CASE
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="setAirflow" Id="{cc113977-e485-4cd4-a01e-b812359ebd45}">
      <Declaration><![CDATA[{attribute 'object_name' := 'setAirflow'}
METHOD setAirflow
VAR_INPUT
	/// Airflow in % 
	In_adiAir_p: ARRAY[1..MAX_NUMBER_OF_OVEN_MODULES] OF DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[adiAir_p := In_adiAir_p;
bSetParam := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{ce678287-d0c0-4c11-aa96-f26232737c22}">
      <Declaration><![CDATA[{attribute 'object_name' := 'Always'}
METHOD PROTECTED Always : BOOL
VAR
	fbOVN: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ----------------------------------------------------------------------------------
// Conditions Always
IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	me.StateMachine.intStateNext := cSTA_OFFBusy;
	me.bolChangeBackToAUTO := FALSE;
END_IF

IF (CIf.SwCfg.bolExist=FALSE) THEN // hardware of controller does not exist
	me.StateMachine.intStateNext := cSTA_SINGLE_ANSWER;
ELSE
	IF (((me.StateMachine.intState=cSTA_INITIALIZED) OR (me.intCmd=cCMD_PON)) 
		AND (me.StateMachine.intState<>cSTA_PONBusy) AND (me.StateMachine.intState<>cSTA_PON)
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)) THEN // switch after startup to PONBusy
		me.StateMachine.intStateNext := cSTA_PONBusy;
		
	ELSIF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.intCmd=cCMD_EOFF)) 
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) 
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)
		AND (me.StateMachine.intState>cSTA_PON)) THEN
		me.StateMachine.intStateNext := cSTA_EOFFBusy;
	
	ELSIF (((me.Alarm.eActivAlmClass=E_AlmClass.OFF) (*OR (me.intCmd=cCMD_OFF)*))
		AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit)
		AND (me.StateMachine.intState<>cSTA_EOFF) AND (me.StateMachine.intState<>cSTA_EOFFBusy)
		AND (me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)
		AND (me.StateMachine.intState>cSTA_PON)) THEN
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	
	END_IF
	
	IF		NOT CIf.SwCfg.bolEnable
		AND (me.StateMachine.intState<>cSTA_OFF)
		AND (me.StateMachine.intState<>cSTA_OFFBusy) THEN
		CIf.Job.intACmd := cCMD_OFF;
	END_IF
	
	Out_bDriverConnected := FALSE;
	IF		(me.StateMachine.intState=cSTA_WRITE) OR (me.StateMachine.intState=cSTA_WRITEBusy)
		OR	(me.StateMachine.intState=cSTA_READ) OR (me.StateMachine.intState=cSTA_READBusy) THEN
		Out_bDriverConnected := TRUE;
	END_IF
	
END_IF

// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState = cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Action Name="setCmdOff" Id="{cf6019e3-6f56-4571-9556-7b2c8be4ce3a}">
      <Implementation>
        <ST><![CDATA[intLatestCmd := 1;

// simulation
iSimStatus := 1;]]></ST>
      </Implementation>
    </Action>
    <Method Name="setSpeed" Id="{e1ee721f-99f7-487d-be02-76937e33dab0}">
      <Declaration><![CDATA[{attribute 'object_name' := 'setSpeed'}
METHOD setSpeed
VAR_INPUT
	/// Belt speed in mm/min 
	In_diSpeed_mm_min: DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[diSpeed_mm_min := In_diSpeed_mm_min;
bSetParam := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Action Name="setCmdBeltOnly" Id="{eb96f45a-ccbb-4b9d-b34a-02806c599568}">
      <Implementation>
        <ST><![CDATA[intLatestCmd := 2;

// simulation
iSimStatus := 2;]]></ST>
      </Implementation>
    </Action>
    <Method Name="sta_CONNECT" Id="{ee8c16a5-8b81-47d9-b812-1c3e8e6f51a5}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_CONNECT'}
METHOD PROTECTED sta_CONNECT : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		;
	END_IF
	
	// State Change Condition
	CASE me.intCmd OF
		// OFF
		Base_PLC.cCMD_OFF:
			me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECTBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_WRITEBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Action Name="setCmdManual" Id="{ef93d172-8b44-42a4-9172-7b1faf91f740}">
      <Implementation>
        <ST><![CDATA[intLatestCmd := 3;

// simulation
iSimStatus := 3;]]></ST>
      </Implementation>
    </Action>
    <Method Name="sta_DISCONNECTBusy" Id="{f12d780c-aad8-4f99-8cd6-b3f5cc2ebfc1}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_DISCONNECTBusy'}
METHOD PROTECTED sta_DISCONNECTBusy : BOOL
VAR
	bBusy: BOOL;
	bError: BOOL;
	udiErrID: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		IF NOT CIf.SwCfg.bolSimulation THEN
			// Close connection
			fbClose(hLink := hLink, bExecute := FALSE);
			fbClose(hLink := hLink, bExecute := TRUE);
		END_IF
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// check status of fbClose
	fbClose(hLink := hLink, bExecute := FALSE, bBusy=>bBusy, bError=>bError, nErrID=>udiErrID);
	
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		bBusy := FALSE;
		bError := FALSE;
		udiErrID := 0;
	END_IF
	
	// State Change Condition
	IF NOT bBusy THEN
		Out_udiDriverErrorID := udiErrID;
		IF bError THEN
			Out_bDriverError := TRUE;
		ELSE
			Out_bDriverError := FALSE;
		END_IF
		me.StateMachine.intStateNext := IBH_CmdState.cSTA_DISCONNECT;
	END_IF

// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>