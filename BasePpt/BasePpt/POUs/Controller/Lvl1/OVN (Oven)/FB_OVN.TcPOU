<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.26">
  <POU Name="FB_OVN" Id="{d4623e6e-93c7-42a6-a41a-a4db5bbad042}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_OVN EXTENDS FB_CtrlBase
VAR_INPUT
	/// 0 = Busy, 1 = OFF, 2 = BeltOn, 3 = Manual, 4 = Run, 5 = Error, 6 = Bundverschlusserkennung 
	In_iStatus: INT;
	/// Machine off 
	In_bOff: BOOL;
	/// Band on 
	In_bBeltOn: BOOL;
	/// Manual 
	In_bManual: BOOL;
	/// Standart drying process 
	In_bRun: BOOL;
	/// Resetting error 
	In_bAckError: BOOL;
	/// Actual temperature in deci °C 
	In_adiTemp_dc: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Aactual airflow in % 
	In_adiAir_p: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF DINT;
	/// Actual belt speed in mm/min 
	In_diSpeed_mm_min: DINT;
	/// 1=Information, 2=Warning, 3=Error 
	In_iErrorLevel: INT;
	/// Error ID (e.g. 100=temperature overflow) 
	In_iErrorID: INT;
	In_bDriverConnected: BOOL;
	In_bDriverError: BOOL;
	In_udiDriverErrorID: UDINT;
	In_uliBarcodeNew_1: ULINT;
	In_uliBarcodeNew_2: ULINT;
	In_uiNewElement_1: UINT;
	In_uiNewElement_2: UINT;
	In_uliBarcodeDelete_1: ULINT;
	In_uliBarcodeDelete_2: ULINT;
	In_uiDeleteElement_1: UINT;
	In_uiDeleteElement_2: UINT;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_OVN;
	/// this allows to detect parameter changes
	lastSifPar: T_Ctrl_SIf_OVN_Par;
	/// pointer to function block
	p_fbIBH: POINTER TO FB_IBH;
	p_fbIBH_CIf: POINTER TO BASE_PLC.T_Ctrl_CIf;
	/// Monitors
	afbTempMonitors: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF FB_MONITOR;
	afbAirMonitors: ARRAY[0..(MAX_NUMBER_OF_OVEN_MODULES - 1)] OF FB_MONITOR;
	fbSpeedMonitor: FB_MONITOR;
	udiTimeInBand: UDINT;
	/// Tracker
	fbTracker: FB_Tracker;
	/// Error Tracking
	iLastCalledAlarmNr: INT;
	uiNewElementOld_1: UINT;
	uiNewElementOld_2: UINT;
	uiDeleteElementOld_1: UINT;
	uiDeleteElementOld_2: UINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Oven Controller Implementation

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		10.12.2013		BB			Start history
___________________________________________________________________________________________________*)

// check if child pointer valid
IF (me.bolActivate) THEN // cyclic call enabled
	
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
		
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
	
END_IF;]]></ST>
    </Implementation>
    <Method Name="sta_PONBusy" Id="{09764ea5-0555-4ab3-bd18-9baa756783b4}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PONBusy'}
METHOD PROTECTED sta_PONBusy : BOOL
VAR
	bReady: BOOL := FALSE;
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Start Driver
		p_fbIBH_CIf^.Job.intACmd := IBH_CmdState.cCMD_CONNECT;
		
		uiNewElementOld_1 := In_uiNewElement_1;
		uiNewElementOld_2 := In_uiNewElement_2;
		uiDeleteElementOld_1 := In_uiDeleteElement_1;
		uiDeleteElementOld_2 := In_uiDeleteElement_2;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------
	
	IF (p_fbIBH_CIf^.Job.intState = cSTA_OFF) THEN
		// Start Driver
		p_fbIBH_CIf^.Job.intACmd := IBH_CmdState.cCMD_CONNECT;
	END_IF
	
	IF THIS^.In_bDriverError THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ConnectionError),UDINT_TO_DINT(THIS^.In_udiDriverErrorID),ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		iLastCalledAlarmNr := E_ALM_OVN.ConnectionError;
	END_IF
	
	// State Change Condition
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_ERROR) THEN
		IF (THIS^.In_bDriverConnected) THEN
			me.StateMachine.intStateNext := Base_PLC.cSTA_PON;
		END_IF
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="IBH" Id="{0b4480b7-3bde-45c6-abd5-acb8b3ccef8a}">
      <Declaration><![CDATA[PROPERTY IBH : POINTER TO FB_IBH]]></Declaration>
      <Get Name="Get" Id="{3b457766-1f3d-4b88-8777-646809f00c9b}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[IBH := p_fbIBH;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{8439f31f-c9f5-4df4-84b7-37de85e15f1a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[p_fbIBH := IBH;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="sta_RUN" Id="{0ea8f62d-75c3-40e2-9ed8-e54946d87e71}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUN'}
METHOD PROTECTED sta_RUN : BOOL
VAR
	uiIdx: UINT;
	bOutOfBand: BOOL := FALSE;
	bError: BOOL := FALSE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		THIS^.lastSifPar := SIf.Par;
		
		// reset monitor timeouts
		fbSpeedMonitor.resetTime();
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules-1 BY 1 DO
			afbTempMonitors[uiIdx].resetTime();
			afbAirMonitors[uiIdx].resetTime();
		END_FOR
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------
	
	// check if parameters have changed
	IF (TC2_SYSTEM.MEMCMP(pBuf1:=ADR(SIf.Par), pBuf2:=ADR(THIS^.lastSifPar), n:=SIZEOF(SIf.Par)) <> 0) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.SettingsChanged),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;
	END_IF
	
	IF NOT In_bRun OR NOT (In_iStatus=4 OR In_iStatus=6 OR In_iStatus=5) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.WrongMode),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
	END_IF
	
	// Update Monitors
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_RUNBusy) THEN
		// temperature monitors
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules-1 BY 1 DO
			afbTempMonitors[uiIdx](	diCurrentValue		:= THIS^.SIf.Cur.adiTemp_dc[uiIdx],
									diTargetValue		:= THIS^.SIf.Par.adiTemp_dc[uiIdx],
									diBand1				:= THIS^.SIf.Par.adiTempBand1_dc[uiIdx],
									diBand2				:= THIS^.SIf.Par.adiTempBand2_dc[uiIdx],
									udiTimeoutBand1_ms	:= THIS^.SIf.Par.audiTempTimeout_ms[uiIdx],
									udiSampleTime_ms	:= me.FUBInfo.udiSample_ms,
									bOutOfBand			=> bOutOfBand,
									bError				=> bError);
			IF (bError = TRUE) THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.TempError),uiIdx,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		END_FOR
		// airflow monitors
		FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules-1 BY 1 DO
			afbAirMonitors[uiIdx](	diCurrentValue		:= THIS^.SIf.Cur.adiAir_p[uiIdx],
									diTargetValue		:= THIS^.SIf.Par.adiAir_p[uiIdx],
									diBand1				:= THIS^.SIf.Par.adiAirBand1_p[uiIdx],
									diBand2				:= THIS^.SIf.Par.adiAirBand2_p[uiIdx],
									udiTimeoutBand1_ms	:= THIS^.SIf.Par.audiAirTimeout_ms[uiIdx],
									udiSampleTime_ms	:= me.FUBInfo.udiSample_ms,
									bOutOfBand			=> bOutOfBand,
									bError				=> bError);
			IF (bError = TRUE) THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.AirError),uiIdx,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		END_FOR
		// band speed monitor
		fbSpeedMonitor(	diCurrentValue		:= THIS^.SIf.Cur.diSpeed_mm_min,
						diTargetValue		:= THIS^.SIf.Par.diSpeed_mm_min,
						diBand1				:= THIS^.SIf.Par.diSpeedBand1_mm_min,
						diBand2				:= THIS^.SIf.Par.diSpeedBand2_mm_min,
						udiTimeoutBand1_ms	:= THIS^.SIf.Par.udiSpeedTimeout_ms,
						udiSampleTime_ms	:= me.FUBInfo.udiSample_ms,
						bOutOfBand			=> bOutOfBand,
						bError				=> bError);
		IF (bError = TRUE) THEN
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.SpeedError),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF
	END_IF
	
	// State Change Condition
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_ERROR) THEN
		CASE me.intCmd OF
			// OFF
			Base_PLC.cCMD_OFF:
				me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
			// BELTONLY
			OVN_CmdState.cCMD_BELTONLY:
				me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
		ELSE
			// DEFAULT
			;
		END_CASE
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{2a33c5c2-2929-43b4-98e4-e525d775c03f}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CtrlInit'}
METHOD CtrlInit : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// add childs
p_fbIBH_CIf := THIS^.AddChild(p_fbIBH^);

// Tracker Init
fbTracker.numberOfModules := SIf.Cfg.uiNumberOfModules;
fbTracker.sampleTime_us := me.FUBInfo.udiSample_us;
fbTracker.moduleLength_mm := SIf.Cfg.diModuleLength_mm;
fbTracker.distanceBeforeOven_mm := SIf.Cfg.diDistanceBeforeOven_mm;	//TODO: BB: This should be the distance from the barcode reader to the begin of the first module of the oven
fbTracker.distanceAfterOven_mm := SIf.Cfg.diDistanceAfterOven_mm;	//TODO: BB: This should be the distance from the barcode reader to the end of the first module of the oven]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkParameter" Id="{461f61da-a69b-4cdc-91b0-f8573fe2e847}">
      <Declaration><![CDATA[{attribute 'object_name' := 'checkParameter'}
METHOD checkParameter : BOOL
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Belt Speed
IF (SIf.Par.diSpeed_mm_min > SIf.Cfg.diMaxSpeed_mm_min) THEN
	pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ParameterWarning),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	SIf.Par.diSpeed_mm_min := SIf.Cfg.diMaxSpeed_mm_min;
ELSIF (SIf.Par.diSpeed_mm_min < SIf.Cfg.diMinSpeed_mm_min) THEN
	pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ParameterWarning),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	SIf.Par.diSpeed_mm_min := SIf.Cfg.diMinSpeed_mm_min;
END_IF

// Temperature
FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules-1 BY 1 DO
	IF (SIf.Par.adiTemp_dc[uiIdx] > SIf.Cfg.diMaxTemp_dc) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ParameterWarning),uiIdx,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		SIf.Par.adiTemp_dc[uiIdx] := SIf.Cfg.diMaxTemp_dc;
	ELSIF (SIf.Par.adiTemp_dc[uiIdx] < SIf.Cfg.diMinTemp_dc) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ParameterWarning),uiIdx,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		SIf.Par.adiTemp_dc[uiIdx] := SIf.Cfg.diMinTemp_dc;
	END_IF
END_FOR

// Airflow
FOR uiIdx:=0 TO SIf.Cfg.uiNumberOfModules-1 BY 1 DO
	IF (SIf.Par.adiAir_p[uiIdx] > SIf.Cfg.diMaxAir_p) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ParameterWarning),uiIdx,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		SIf.Par.adiAir_p[uiIdx] := SIf.Cfg.diMaxAir_p;
	ELSIF (SIf.Par.adiAir_p[uiIdx] < SIf.Cfg.diMinAir_p) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ParameterWarning),uiIdx,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		SIf.Par.adiAir_p[uiIdx] := SIf.Cfg.diMinAir_p;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{4e39778e-86f6-46f0-a7cb-954ff485b184}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFF'}
METHOD PROTECTED sta_OFF : BOOL
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------
	
	IF NOT In_bOff OR NOT (In_iStatus=1 OR In_iStatus=6 OR In_iStatus=5) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.WrongMode),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
	END_IF
	
	// State Change Condition
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_ERROR) THEN
		CASE me.intCmd OF
			// RUN
			Base_PLC.cCMD_RUN:
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;
			// BELTONLY
			OVN_CmdState.cCMD_BELTONLY:
				me.StateMachine.intStateNext := OVN_CmdState.cSTA_BELTONLYBusy;
		ELSE
			// DEFAULT
			;
		END_CASE
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{634d05b0-aae5-4c56-83e0-8a71e0aadd76}">
      <Declaration><![CDATA[{attribute 'object_name' := 'FB_init'}
METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR uiIdx:=0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[uiIdx].intCmd=cSTA_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

// Add configuration of own comands
CIf.Job.aCmdList[uiIdx].intCmd := OVN_CmdState.cCMD_BELTONLY;
CIf.Job.aCmdList[uiIdx].strName := 'BELTONLY';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;
uiIdx := uiIdx+1;
CIf.Job.aCmdList[uiIdx].intCmd := Base_PLC.cCMD_RUN;
CIf.Job.aCmdList[uiIdx].strName := 'RUN';
CIf.Job.aCmdList[uiIdx].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_OVN';
CIf.Info.strFullName := 'Oven';

// set alarm class
SIf.Alm[E_ALM_OVN.TempError].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.TempError].strText := 'Temperature Error';
SIf.Alm[E_ALM_OVN.AirError].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.AirError].strText := 'Airflow Error';
SIf.Alm[E_ALM_OVN.SpeedError].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.SpeedError].strText := 'Band Speed Error';
SIf.Alm[E_ALM_OVN.TimeoutError].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.TimeoutError].strText := 'Timeout Error on State Change';
SIf.Alm[E_ALM_OVN.ParameterWarning].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[E_ALM_OVN.ParameterWarning].strText := 'Parameter Warning - Parameters got adjusted within the allowed limits';
SIf.Alm[E_ALM_OVN.ConnectionError].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.ConnectionError].strText := 'Connection Error';
SIf.Alm[E_ALM_OVN.WrongMode].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.WrongMode].strText := 'Wrong Mode - Possible Manual Intervention';

SIf.Alm[E_ALM_OVN.Tesoma10000].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10000].strText := 'Tesoma - Overtemperature Power Section';
SIf.Alm[E_ALM_OVN.Tesoma10002].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10002].strText := 'Tesoma - Failure of Active Cooling Unit';
SIf.Alm[E_ALM_OVN.Tesoma10003].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10003].strText := 'Tesoma - Active Cooling Unit not Running';
SIf.Alm[E_ALM_OVN.Tesoma10006].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10006].strText := 'Tesoma - Failure Fuse General';
SIf.Alm[E_ALM_OVN.Tesoma10010].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10010].strText := 'Tesoma - Belt Position Control Sensor Error';
SIf.Alm[E_ALM_OVN.Tesoma10011].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10011].strText := 'Tesoma - Belt Edge Shut Off';
SIf.Alm[E_ALM_OVN.Tesoma10012].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10012].strText := 'Tesoma - Fault Belt Speed';
SIf.Alm[E_ALM_OVN.Tesoma10013].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10013].strText := 'Tesoma - Transport Overload';
SIf.Alm[E_ALM_OVN.Tesoma10014].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10014].strText := 'Tesoma - Belt Control Device Fault';
SIf.Alm[E_ALM_OVN.Tesoma10016].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10016].strText := 'Tesoma - Emergency Stop';
SIf.Alm[E_ALM_OVN.Tesoma10023].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10023].strText := 'Tesoma - Belt Wear Monitor';
SIf.Alm[E_ALM_OVN.Tesoma10024].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10024].strText := 'Tesoma - Control Cabinet Fan';
SIf.Alm[E_ALM_OVN.Tesoma10025].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10025].strText := 'Tesoma - Control Cabinet Temperature too High';
SIf.Alm[E_ALM_OVN.Tesoma10026].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10026].strText := 'Tesoma - Power Supply Failure';
SIf.Alm[E_ALM_OVN.Tesoma10027].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10027].strText := 'Tesoma - Intake Hood Temperature Exceeded';
SIf.Alm[E_ALM_OVN.Tesoma10030].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10030].strText := 'Tesoma - Air Pressure too low';
SIf.Alm[E_ALM_OVN.Tesoma10031].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10031].strText := 'Tesoma - Belt Position Control not Working';
SIf.Alm[E_ALM_OVN.Tesoma10032].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10032].strText := 'Tesoma - Error Cooling Device Control Cabinet';
SIf.Alm[E_ALM_OVN.Tesoma10034].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10034].strText := 'Tesoma - Control Cabinet Cooler and Small Drives Fuse Failure';
SIf.Alm[E_ALM_OVN.Tesoma10x00].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10x00].strText := 'Tesoma - LimitSwitchingOff';
SIf.Alm[E_ALM_OVN.Tesoma10x01].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10x01].strText := 'Tesoma - Overtemperature Safety Temperature Limiter';
SIf.Alm[E_ALM_OVN.Tesoma10x02].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10x02].strText := 'Tesoma - Fuse Triggered';
SIf.Alm[E_ALM_OVN.Tesoma10x03].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10x03].strText := 'Tesoma - Failure Exhaust Air Differential Pressure Sensor';
SIf.Alm[E_ALM_OVN.Tesoma10x07].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10x07].strText := 'Tesoma - Error Frequency Converter';
SIf.Alm[E_ALM_OVN.Tesoma10x13].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10x13].strText := 'Tesoma - Temperature Sensor IR Defective';
SIf.Alm[E_ALM_OVN.Tesoma10x14].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10x14].strText := 'Tesoma - Fault Frame Cooling System Differential Pressure Sensor';
SIf.Alm[E_ALM_OVN.Tesoma10x15].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma10x15].strText := 'Tesoma - Fault Exhaust Air Differential Pressure Sensor';
SIf.Alm[E_ALM_OVN.Tesoma13x00].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.Tesoma13x00].strText := 'Tesoma - Temperature Fault';
SIf.Alm[E_ALM_OVN.TesomaUnknown].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.TesomaUnknown].strText := 'Tesoma - Unknown Error';
SIf.Alm[E_ALM_OVN.HostConnectionLost].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.HostConnectionLost].strText := 'Saber Communication Lost';
SIf.Alm[E_ALM_OVN.SettingsChanged].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[E_ALM_OVN.SettingsChanged].strText := 'Settings Changed';

//*******************************************************************************
// initial values
//*******************************************************************************

// Software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolEnable := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// Configuration
SIf.Cfg.uiNumberOfModules := 4;
SIf.Cfg.diModuleLength_mm := 2000;
SIf.Cfg.diDistanceBeforeOven_mm := 1000;
SIf.Cfg.diDistanceAfterOven_mm := 1000;
SIf.Cfg.diMinAir_p := 40;
SIf.Cfg.diMaxAir_p := 100;
SIf.Cfg.diMaxSpeed_mm_min := 30000;
SIf.Cfg.diMinSpeed_mm_min := 3000;
SIf.Cfg.diMinTemp_dc := 0;
SIf.Cfg.diMaxTemp_dc := 2000;
SIf.Cfg.bAutoContinueAfterConnectionError := FALSE;
SIf.Cfg.bolDataChannelEnable := FALSE;
SIf.Cfg.bIgnoreOffBusyWaitPaper := FALSE;

// Parameter
SIf.Par.diSpeed_mm_min := SIf.Cfg.diMinSpeed_mm_min;
SIf.Par.diSpeedBand1_mm_min := 100;
SIf.Par.diSpeedBand2_mm_min := 200;
SIf.Par.udiSpeedTimeout_ms := 5000;
SIf.Par.udiTimeoutOffBusy_ms := 2000;
SIf.Par.udiTimeoutRunBusyReaction_ms := 2*1000;
SIf.Par.udiTimeoutRunBusyInBand_ms := 1*60*1000;
SIf.Par.udiTimeoutBeltOnlyReaction_ms := 1000;
SIf.Par.udiTimeoutBeltOnlyBusy_ms := 10000;

FOR uiIdx:=0 TO MAX_NUMBER_OF_OVEN_MODULES-1 BY 1 DO
	SIf.Par.adiTemp_dc[uiIdx] := 1000;
	SIf.Par.adiTempBand1_dc[uiIdx] := 30;
	SIf.Par.adiTempBand2_dc[uiIdx] := 60;
	SIf.Par.audiTempTimeout_ms[uiIdx] := 5000;
	SIf.Par.adiAir_p[uiIdx] := SIf.Cfg.diMinAir_p;
	SIf.Par.adiAirBand1_p[uiIdx] := 2;
	SIf.Par.adiAirBand2_p[uiIdx] := 4;
	SIf.Par.audiAirTimeout_ms[uiIdx] := 5000;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="chooseTesomaErrors" Id="{82894b6e-8205-4d89-aa41-938c35174021}">
      <Declaration><![CDATA[{attribute 'object_name' := 'chooseTesomaErrors'}
METHOD chooseTesomaErrors : BOOL
VAR_IN_OUT
	bResettable: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bResettable := FALSE;

CASE THIS^.In_iErrorID OF
	// Tesoma10000
	10000:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10000),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10002
	10002:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10002),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10003
	10003:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10003),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10006
	10006:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10006),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10010
	10010:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10010),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10011
	10011:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10011),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10012
	10012:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10012),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10013
	10013:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10013),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10014
	10014:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10014),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10016
	10016:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10016),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10023
	10023:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10023),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10024
	10024:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10024),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10025
	10025:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10025),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10026
	10026:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10026),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10027
	10027:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10027),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10030
	10030:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10030),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10031
	10031:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10031),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10032
	10032:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10032),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10034
	10034:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10034),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10x00
	10100, 10200, 10300, 10400, 10500, 10600, 10700, 10800, 10900:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10x00),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10x01
	10101, 10201, 10301, 10401, 10501, 10601, 10701, 10801, 10901:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10x01),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10x02
	10102, 10202, 10302, 10402, 10502, 10602, 10702, 10802, 10902:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10x02),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10x03
	10103, 10203, 10303, 10403, 10503, 10603, 10703, 10803, 10903:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10x03),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10x07
	10107, 10207, 10307, 10407, 10507, 10607, 10707, 10807, 10907:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10x07),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10x13
	10113, 10213, 10313, 10413, 10513, 10613, 10713, 10813, 10913:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10x13),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10x14
	10114, 10214, 10314, 10414, 10514, 10614, 10714, 10814, 10914:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10x14),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma10x15
	10115, 10215, 10315, 10415, 10515, 10615, 10715, 10815, 10915:
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma10x15),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	// Tesoma13x00
	13100, 13200, 13300, 13400, 13500, 13600, 13700, 13800, 13900:
		bResettable := TRUE;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.Tesoma13x00),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
ELSE
	// TesomaUnknown
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.TesomaUnknown),In_iErrorID,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Property Name="CtrlSIf" Id="{88e71e60-cf7d-426c-97d7-afaf858362e5}">
      <Declaration><![CDATA[PROPERTY PUBLIC CtrlSIf : POINTER TO T_Ctrl_SIf_OVN]]></Declaration>
      <Get Name="Get" Id="{c94c05ae-47d3-42a5-b512-6fc1e70efd2e}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[CtrlSIf := ADR(SIf);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="sta_ERROR" Id="{8be44ae0-c6d5-4bb8-8bb6-82295e13fffe}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERROR'}
METHOD PROTECTED sta_ERROR : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// Mark all tracked item as trash
	fbTracker.markAllTrash();
	
	// auto continue after Connection Error
	IF (iLastCalledAlarmNr=E_ALM_OVN.ConnectionError AND SIf.Cfg.bAutoContinueAfterConnectionError) THEN
		IF THIS^.In_bDriverConnected THEN
			CIf.Job.bolAlmReset := TRUE;
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ConnectionError),UDINT_TO_DINT(THIS^.In_udiDriverErrorID),ADR(SIf.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
		END_IF
	END_IF
	
	// State Change Condition
	IF (CIf.Job.bolAlmReset = TRUE) THEN
		IF (p_fbIBH_CIf^.Job.intState = cSTA_OFF) THEN
			// Start Driver
			p_fbIBH_CIf^.Job.intACmd := IBH_CmdState.cCMD_CONNECT;
		END_IF
		p_fbIBH^.setAckError();
		me.StateMachine.intStateNext := cSTA_ERRORQuit;
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{90a3e2a7-420f-4d7d-a680-bf47fb55745a}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCmdState'}
METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states

IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
		CASE intCmdState OF
			OVN_CmdState.cCMD_BELTONLY:
				getCmdState := 'BELTONLY';
		ELSE
			getCmdState := 'Cmd not defined';
		END_CASE;
	ELSE
		// state's
		CASE intCmdState OF
			OVN_CmdState.cSTA_BELTONLY: 
				getCmdState := 'BELTONLY';
			OVN_CmdState.cSTA_BELTONLYbusy: 
				getCmdState := 'BELTONLYbusy';
			OVN_CmdState.cSUB_WAITOFF: 
				getCmdState := 'WAITOFF';
			OVN_CmdState.cSUB_WAITPAPER: 
				getCmdState := 'WAITPAPER';
			OVN_CmdState.cSUB_DONE: 
				getCmdState := 'DONE';
		ELSE
			getCmdState := 'State not defined';
		END_CASE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{92f4de2c-89b2-4610-a1cf-ca3d87a3484b}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_RUNBusy'}
METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	iIdx: UINT;
	bReady: BOOL;
	iErrorNumber: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Set Outputs
		p_fbIBH^.setRun();
		p_fbIBH^.setSpeed(In_diSpeed_mm_min := SIf.Par.diSpeed_mm_min);
		p_fbIBH^.setTemp(In_adiTemp_dc := SIf.Par.adiTemp_dc);
		p_fbIBH^.setAirflow(In_adiAir_p := SIf.Par.adiAir_p);
		THIS^.lastSifPar := SIf.Par;
		
		udiTimeInBand := 0;
		
		// delete all tracked items
		fbTracker.deleteAll();
	END_IF
	
// Cyclic action
//--------------------------------------------------------------------------------------
	
	// check if parameters have changed
	IF (TC2_SYSTEM.MEMCMP(pBuf1:=ADR(SIf.Par), pBuf2:=ADR(THIS^.lastSifPar), n:=SIZEOF(SIf.Par)) <> 0) THEN
		p_fbIBH^.setSpeed(In_diSpeed_mm_min := SIf.Par.diSpeed_mm_min);
		p_fbIBH^.setTemp(In_adiTemp_dc := SIf.Par.adiTemp_dc);
		p_fbIBH^.setAirflow(In_adiAir_p := SIf.Par.adiAir_p);
		THIS^.lastSifPar := SIf.Par;
	END_IF
	
	// check timeouts
	IF me.StateMachine.udiTimeInState_ms>SIf.Par.udiTimeoutRunBusyReaction_ms THEN
		IF NOT In_bRun OR NOT ((In_iStatus=0) OR (In_iStatus=4) OR (In_iStatus=6)) THEN
			iErrorNumber := 100*me.StateMachine.intState+In_iStatus;
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.TimeoutError),iErrorNumber,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF
	END_IF
	
	// Check if ready
	bReady := TRUE;
	IF NOT In_bRun OR NOT (In_iStatus=4) THEN	// ignoring In_iStatus=6 since it's only temporary
		bReady := FALSE;
	END_IF
	IF (ABS(THIS^.In_diSpeed_mm_min - SIf.Par.diSpeed_mm_min) > ABS(SIf.Par.diSpeedBand1_mm_min)) THEN
		bReady := FALSE;
	END_IF
	FOR iIdx:=0 TO SIf.Cfg.uiNumberOfModules-1 BY 1 DO
		// Temperature
		IF (ABS(THIS^.In_adiTemp_dc[iIdx] - SIf.Par.adiTemp_dc[iIdx]) > ABS(THIS^.SIf.Par.adiTempBand1_dc[iIdx])) THEN
			bReady := FALSE;
		END_IF
		// Airflow
		IF (ABS(THIS^.In_adiAir_p[iIdx] - THIS^.SIf.Par.adiAir_p[iIdx]) > ABS(THIS^.SIf.Par.adiAirBand1_p[iIdx])) THEN
			bReady := FALSE;
		END_IF
	END_FOR
	
	IF bReady THEN
		udiTimeInBand := udiTimeInBand + me.FUBInfo.udiSample_ms;
		IF udiTimeInBand < SIf.Par.udiTimeoutRunBusyInBand_ms THEN
			bReady := FALSE;
		END_IF
	ELSE
		udiTimeInBand := 0;
	END_IF
	
	// State Change Condition
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_ERROR) THEN
		CASE me.intCmd OF
			// OFF
			Base_PLC.cCMD_OFF:
				me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
			// BELTONLY
			OVN_CmdState.cCMD_BELTONLY:
				me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
		ELSE
			// DEFAULT
			IF bReady THEN
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUN;
			END_IF
		END_CASE
	END_IF

		
// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{a92240fc-5d33-4a2d-ac8d-c1cc3cb1e285}">
      <Declaration><![CDATA[{attribute 'object_name' := 'Always'}
METHOD PROTECTED Always : BOOL
VAR
	fbOVN: INT;
	bResettable: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	// copy number of modules to IBH driver
	p_fbIBH^.getCtrlSIf()^.Cfg.uiNumberOfModules := SIf.Cfg.uiNumberOfModules;
	
	// check parameter from GUI
	THIS^.checkParameter();
	
	// write input values directly to SIf.Cur
	SIf.Cur.diSpeed_mm_min := THIS^.In_diSpeed_mm_min;
	SIf.Cur.adiAir_p := THIS^.In_adiAir_p;
	SIf.Cur.adiTemp_dc := THIS^.In_adiTemp_dc;
	
	// remove old elements from Tracker
	IF In_uiDeleteElement_1<>uiDeleteElementOld_1 THEN
		uiDeleteElementOld_1 := In_uiDeleteElement_1;
		fbTracker.deleteElement(In_uliBarcodeDelete_1, SIf.Cfg.bolDataChannelEnable);
	END_IF
	IF In_uiDeleteElement_2<>uiDeleteElementOld_2 THEN
		uiDeleteElementOld_2 := In_uiDeleteElement_2;
		fbTracker.deleteElement(In_uliBarcodeDelete_2, SIf.Cfg.bolDataChannelEnable);
	END_IF
	
	// update Tracker
	fbTracker.update(In_adiTemp_mc:=In_adiTemp_dc, In_diSpeed_mm_min:=In_diSpeed_mm_min,bolSendToSaber:=SIf.Cfg.bolDataChannelEnable);
	
	// add new elements to Tracker
	IF In_uiNewElement_1<>uiNewElementOld_1 THEN
		uiNewElementOld_1 := In_uiNewElement_1;
		fbTracker.addElement(In_uliBarcodeNew_1);
	END_IF
	IF In_uiNewElement_2<>uiNewElementOld_2 THEN
		uiNewElementOld_2 := In_uiNewElement_2;
		fbTracker.addElement(In_uliBarcodeNew_2);
	END_IF
	
	// check errors when higher than PONBusy
	IF (me.StateMachine.intState>=Base_PLC.cSTA_PON) AND (NOT CIf.SwCfg.bolSimulation) THEN
		
		// go to error if Driver connection is lost
		IF 		NOT THIS^.In_bDriverConnected
			AND	me.StateMachine.intState<>Base_PLC.cSTA_ERROR
			AND	me.StateMachine.intState<>Base_PLC.cSTA_ERRORQuit THEN
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.ConnectionError),UDINT_TO_DINT(THIS^.In_udiDriverErrorID),ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
				iLastCalledAlarmNr := E_ALM_OVN.ConnectionError;
		END_IF
		
		// check Tesoma Errors, ErrorLevel 1 (Info) and 2 (Warning) don't exist
		IF THIS^.In_iErrorLevel=3 THEN
			chooseTesomaErrors(bResettable);
			IF 		me.StateMachine.intState<>Base_PLC.cSTA_ERROR
				AND	me.StateMachine.intState<>Base_PLC.cSTA_ERRORQuit
				and me.StateMachine.intStateNext<>Base_PLC.cSTA_ERROR THEN
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
			END_IF
		END_IF
		
	END_IF
	
END_IF

// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState = cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{d8673dce-427e-4f92-84cb-c01c9f1b5157}">
      <Declaration><![CDATA[{attribute 'object_name' := 'StateMachine'}
METHOD PROTECTED StateMachine : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	// BELTONLY
    OVN_CmdState.cSTA_BELTONLY: 
        THIS^.sta_BELTONLY();
    OVN_CmdState.cSTA_BELTONLYBusy: 
        THIS^.sta_BELTONLYBusy();
	// RUN
	Base_PLC.cSTA_RUN:
		THIS^.sta_RUN();
	Base_PLC.cSTA_RUNBusy:
		THIS^.sta_RUNBusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{da5770fa-bc28-4fb4-bd44-52ca2d422777}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PON'}
METHOD PROTECTED sta_PON : BOOL
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------
	
	// State Change Condition
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_ERROR) THEN
		IF me.intCmd>Base_PLC.cCMD_PON THEN
			me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
		END_IF
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{dce80cb8-7c24-4fdf-9f71-c6d24e7d4d05}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_OFFBusy'}
METHOD PROTECTED sta_OFFBusy : BOOL
VAR
	bReady: BOOL;
	iErrorNumber: INT;
	uiIdx: UINT;
	udiCoolDownTime_ms: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		me.SubStateMachine.intState 	:= OVN_CmdState.cSUB_WAITOFF;
		me.SubStateMachine.intStateNext := OVN_CmdState.cSUB_WAITOFF;
		
		// Set Outputs
		p_fbIBH^.setOff();
		
		// mark all tracked items as trash
		fbTracker.markAllTrash();
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------
	
	CASE me.SubStateMachine.intState OF
			// WAITOFF
			// ------------------------------------------------------------------------
			OVN_CmdState.cSUB_WAITOFF:
				IF (In_bOff AND ((In_iStatus=1) OR (In_iStatus=6))) THEN
					me.SubStateMachine.intStateNext := OVN_CmdState.cSUB_WAITPAPER;
				ELSIF (me.StateMachine.udiTimeInState_ms>SIf.Par.udiTimeoutOffBusy_ms) THEN
					iErrorNumber := 100*me.StateMachine.intState+In_iStatus;
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.TimeoutError),iErrorNumber,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
				END_IF
				
			// WAITPAPER
			// ------------------------------------------------------------------------
			OVN_CmdState.cSUB_WAITPAPER:
				IF NOT In_bOff OR NOT (In_iStatus=1 OR In_iStatus=6 OR In_iStatus=5) THEN
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.WrongMode),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
				END_IF
			
				udiCoolDownTime_ms := DINT_TO_UDINT((SIf.Cfg.uiNumberOfModules*SIf.Cfg.diModuleLength_mm+SIf.Cfg.diDistanceBeforeOven_mm+SIf.Cfg.diDistanceAfterOven_mm)*60*1000/SIf.Par.diSpeed_mm_min);
				IF (me.StateMachine.udiTimeInState_ms>udiCoolDownTime_ms) OR SIf.Cfg.bIgnoreOffBusyWaitPaper THEN
					me.SubStateMachine.intStateNext := OVN_CmdState.cSUB_DONE;
				END_IF
				
			// DONE
			// ------------------------------------------------------------------------
			OVN_CmdState.cSUB_DONE:
				;
	END_CASE
	
	// State Change Condition
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_ERROR) THEN
		CASE me.intCmd OF
			// RUN
			Base_PLC.cCMD_RUN:
				me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;
			// BELTONLY
			OVN_CmdState.cCMD_BELTONLY:
				me.StateMachine.intStateNext := OVN_CmdState.cSTA_BELTONLYBusy;
		ELSE
			// DEFAULT
			IF (me.SubStateMachine.intState=OVN_CmdState.cSUB_DONE) THEN
				me.StateMachine.intStateNext := Base_PLC.cCMD_OFF;
			END_IF
		END_CASE
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_BELTONLYBusy" Id="{e816f287-6e50-426f-8156-39d63c59079d}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_BELTONLYBusy'}
METHOD PROTECTED sta_BELTONLYBusy : BOOL
VAR
	uiIdx: UINT;
	bReady: BOOL;
	iErrorNumber: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Set Outputs
		p_fbIBH^.setBeltOn();
		p_fbIBH^.setSpeed(In_diSpeed_mm_min := SIf.Par.diSpeed_mm_min);
		THIS^.lastSifPar := SIf.Par;
	END_IF
	
	
// Cyclic action
//--------------------------------------------------------------------------------------
	
	// check if parameters have changed
	IF (TC2_SYSTEM.MEMCMP(pBuf1:=ADR(SIf.Par), pBuf2:=ADR(THIS^.lastSifPar), n:=SIZEOF(SIf.Par)) <> 0) THEN
		p_fbIBH^.setSpeed(In_diSpeed_mm_min := SIf.Par.diSpeed_mm_min);
		THIS^.lastSifPar := SIf.Par;
	END_IF
	
	// check timeouts
	IF me.StateMachine.udiTimeInState_ms>SIf.Par.udiTimeoutBeltOnlyBusy_ms THEN
		iErrorNumber := 100*me.StateMachine.intState+In_iStatus;
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.TimeoutError),iErrorNumber,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
	ELSIF me.StateMachine.udiTimeInState_ms>SIf.Par.udiTimeoutBeltOnlyReaction_ms THEN
		IF NOT In_bBeltOn OR NOT ((In_iStatus=2) OR (In_iStatus=6)) THEN
			iErrorNumber := 100*me.StateMachine.intState+In_iStatus;
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.TimeoutError),iErrorNumber,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
		END_IF
	END_IF
	
	// Check if ready
	bReady := TRUE;
	IF NOT In_bBeltOn OR NOT ((In_iStatus=2) OR (In_iStatus=6)) THEN
		bReady := FALSE;
	END_IF
	IF (ABS(THIS^.In_diSpeed_mm_min - SIf.Par.diSpeed_mm_min) > ABS(SIf.Par.diSpeedBand1_mm_min)) THEN
		bReady := FALSE;
	END_IF
	
	// State Change Condition
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_ERROR) THEN
		CASE me.intCmd OF
			// OFF
			Base_PLC.cCMD_OFF:
				me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
		ELSE
			// DEFAULT
			IF bReady THEN
				me.StateMachine.intStateNext := OVN_CmdState.cSTA_BELTONLY;
			END_IF
		END_CASE
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{e8890661-eb02-49d5-a71a-b91c93c31ffb}">
      <Declaration><![CDATA[{attribute 'object_name' := 'getCtrlSIf'}
METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_OVN]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Property Name="DataChannel" Id="{e958c2e0-9251-41de-ab54-10e3fb2d939f}">
      <Declaration><![CDATA[PROPERTY DataChannel : POINTER TO FB_DataChannelSenderFifo]]></Declaration>
      <Set Name="Set" Id="{226626be-f4fc-4e44-ac7c-c5a827ac2bfc}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[fbTracker.DataChannel := DataChannel;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="sta_ERRORQuit" Id="{e9ab53d3-ca72-481e-a944-6fa5721b31b2}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_ERRORQuit'}
METHOD PROTECTED sta_ERRORQuit : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------	
	
	// State Change Condition
	CASE me.StateMachine.intStateHistory OF
		// RUN
		Base_PLC.cSTA_RUN, Base_PLC.cSTA_RUNBusy:
			me.StateMachine.intStateNext := Base_PLC.cSTA_RUNBusy;
		// PON
		Base_PLC.cSTA_PON, Base_PLC.cSTA_PONBusy:
			me.StateMachine.intStateNext := Base_PLC.cSTA_PONBusy;
		// STOP
		Base_PLC.cSTA_STOP, Base_PLC.cSTA_STOPBusy:
			me.StateMachine.intStateNext := Base_PLC.cSTA_STOPBusy;
		// BELTONLY
		OVN_CmdState.cSTA_BELTONLY, OVN_CmdState.cSTA_BELTONLYBusy:
			me.StateMachine.intStateNext := OVN_CmdState.cSTA_BELTONLYBusy;
	ELSE
		// DEFAULT
		me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
	END_CASE


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		
		// Reset iLastCalledAlarmNr
		iLastCalledAlarmNr := E_ALM_OVN.NONE;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_BELTONLY" Id="{ef13c3e6-1be7-4d47-88b2-2246ce4bd4fa}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_BELTONLY'}
METHOD PROTECTED sta_BELTONLY : BOOL
VAR
	uiIdx: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation

// Entry action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateLastCycle) THEN
		// state changed since last cycle
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
// Cyclic action
//--------------------------------------------------------------------------------------

	// check if parameters have changed
	IF (TC2_SYSTEM.MEMCMP(pBuf1:=ADR(SIf.Par), pBuf2:=ADR(THIS^.lastSifPar), n:=SIZEOF(SIf.Par)) <> 0) THEN
		me.StateMachine.intStateNext := OVN_CmdState.cSTA_BELTONLYBusy;
	END_IF
	
	IF NOT In_bBeltOn OR NOT (In_iStatus=2 OR In_iStatus=6 OR In_iStatus=5) THEN
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,INT_TO_UDINT(E_ALM_OVN.WrongMode),0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		me.StateMachine.intStateNext := Base_PLC.cSTA_ERROR;
	END_IF
	
	// State Change Condition
	IF (me.StateMachine.intStateNext <> Base_PLC.cSTA_ERROR) THEN
		CASE me.intCmd OF
			Base_PLC.cCMD_OFF:
				me.StateMachine.intStateNext := Base_PLC.cSTA_OFFBusy;
		END_CASE
	END_IF


// Exit action
//--------------------------------------------------------------------------------------
	IF (me.StateMachine.intState <> me.StateMachine.intStateNext) THEN
		// state is going to change
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>